<!DOCTYPE html>
<html  xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>GlassFish Wiki : GlassFish User-Managed Clusters Design - take 1 (obsolete)</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="" />
        <meta http-equiv="content-language" content="en" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap.min.css" rel="stylesheet" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
        <link href="styles/docs.css" rel="stylesheet" />
        <link href="styles/site1.css" rel="stylesheet" />
        <style> a { color: #555555; } </style>
        <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body class="page-documentation project-gfmvnsite" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

        <div class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <div class="brand"><a href="/glassfish/index.html"><img src="../images/gflogo24.png"><span style="color:#E88A43;font-size:18px;padding-left:11px;padding-top:15px;font-weight:bold;">GlassFish</span> - <span style="font-size:18px;" class="gf-grey">World's first Java EE 7 Application Server</span></a></div>
                    <div class="nav-collapse">
                        <ul class="nav pull-right">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                                <ul class="dropdown-menu">
									<li><a href="/glassfish/LICENSE" title="License">Legal </a></li>
									<li><a href="/glassfish/CONTRIBUTING" title="Contributing">Contributing </a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><!--/.nav-collapse -->
                </div>
            </div>
        </div>

        <br/><br/>
        <div class="container"><body> 
 <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff"> 
  <tbody>
   <tr> 
    <td valign="top" class="pagebody">   <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GlassFishUserManagedClustersDesignSpectake1%28obsolete%29"></a>GlassFish User-Managed Clusters Design Spec - take 1 (obsolete)</h1> <p>This is the design specification for the user-managed clusters feature for GlassFish.</p> <p><b>Authors</b></p> 
     <ul> 
      <li>Tom Mueller (<a href="mailto:Tom.Mueller@oracle.com">Tom.Mueller@oracle.com</a> )</li> 
      <li>Rajiv Mordani (<a href="mailto:Rajiv.Mordani@oracle.com">Rajiv.Mordani@oracle.com</a> )</li> 
      <li>Chris Kasso (<a href="mailto:Chris.Kasso@oracle.com">Chris.Kasso@oracle.com</a> )</li> 
      <li>Jennifer Chou (<a href="mailto:Chris.Kasso@oracle.com">Jennifer.Chou@oracle.com</a> ) 
       <hr> 
       <div> 
        <ul> 
         <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GlassFishUserManagedClustersDesignSpectake1%28obsolete%29">GlassFish User-Managed Clusters Design Spec - take 1 (obsolete)</a></li> 
         <ul> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Introduction">Introduction</a></li> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Requirements">Requirements</a></li> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GeneralDesign">General Design</a></li> 
          <ul> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Domains%2CClusters%2CandInstances">Domains, Clusters, and Instances</a></li> 
          </ul> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ConfigurationchangestoremoveisDas%28%29calls">Configuration changes to remove isDas() calls</a></li> 
          <ul> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-AnalysisofisDas%28%29">Analysis of isDas()</a></li> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-AnalysisofisInstance%28%29">Analysis of isInstance()</a></li> 
          </ul> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-CommandChanges">Command Changes</a></li> 
          <ul> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GeneralDASonlyasadminCommandChanges">General DAS-only asadmin Command Changes</a></li> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-SpecificExistingCommandChanges">Specific Existing Command Changes</a></li> 
           <ul> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-LocalInstanceCommands">Local Instance Commands</a></li> 
            <ul> 
             <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-createlocalinstance">create-local-instance</a></li> 
             <ul> 
              <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-usermanagedinstance.xmlTemplate">user-managed-instance.xml Template</a></li> 
             </ul> 
             <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-deletelocalinstance">delete-local-instance</a></li> 
             <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-startlocalinstance">start-local-instance</a></li> 
             <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-stoplocalinstance">stop-local-instance</a></li> 
            </ul> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Deploy">Deploy</a></li> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-listcommandsCommand">list-commands Command</a></li> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-createserviceCommand">create-service Command</a></li> 
           </ul> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-NewCommands">New Commands</a></li> 
           <ul> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ListingLocalInstances">Listing Local Instances</a></li> 
            <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Backup%2FRestore">Backup/Restore</a></li> 
           </ul> 
          </ul> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-SecurityChanges">Security Changes</a></li> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ContainerIssues">Container Issues</a></li> 
          <ul> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ApplicationId">Application Id</a></li> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Timers">Timers</a></li> 
           <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Transactions">Transactions</a></li> 
          </ul> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ClusteringforJMS%2FMQ">Clustering for JMS/MQ</a></li> 
          <li><a href="#GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Upgrade">Upgrade</a></li> 
         </ul> 
        </ul>
       </div></li> 
     </ul> 
     <hr> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Introduction"></a>Introduction</h2> <p>In the GlassFish 3.1 release, clusters and clustered instances are managed by a domain administration server (DAS). &nbsp;The DAS is required to create, list, start, stop, and delete a cluster and the instances that are in a cluster. Configuration information is synchronized with members of the cluster by the DAS. &nbsp;The user-managed cluster feature provides the ability to create a cluster of instances without using a DAS. &nbsp;Responsibility for managing the cluster and its instances rests with the user, either by manually updating the configuration of each instance or by providing an external software system that does this management. &nbsp;Since the user provides the management for the cluster, the feature is called user-managed clusters.</p> <p>The purpose of this document is to describe the design for the feature. This includes the following sections:</p> 
     <ul> 
      <li>General information about how the feature works</li> 
      <li>Analysis of the use of the isDas method within the server and how these calls need to be changed</li> 
      <li>Changes to asadmin subcommands, including information about the changes need for commands that are executed only on a DAS, changes to existing command for managing instances, and new commands</li> 
      <li>Security changes related to how the asadmin command connects to instances</li> 
      <li>Various issues with containers including handling of the application id for the EJB container, timer management, and transaction management</li> 
      <li>Changes needed for JMS and Message Queue integration with clustering</li> 
     </ul> <p>Additional high level information about the requirements and design, such as packaging, i18n/l10n impact, etc. is available in the <a href="User-Managed Clusters.html" title="User-Managed Clusters">one-pager/project page</a> for this feature. That information is not duplicated in this document.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Requirements"></a>Requirements</h2> <p>The <a href="./User-Managed+Clusters#User-ManagedClusters-3.2.FeatureList%28TechnicalRequirements%29.html">requirements</a> for this feature are specified on the one-pager/project page&nbsp;for this feature.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GeneralDesign"></a>General Design</h2> <p>The basic idea for this feature is to allow a server running with the RuntimeType &nbsp;INSTANCE to be configured so that it accepts and processes asadmin requests directly rather than only accepting them from the DAS. The user or a user-provided software system will need to submit the commands to the instance. &nbsp;This basic idea has an impact across several areas of GlassFish and dealing with this impact is the subject of the remaining sections in this design.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Domains%2CClusters%2CandInstances"></a>Domains, Clusters, and Instances</h3> <p>When using the user-managed cluster feature, a domain can contain exactly one cluster, i.e., there is a 1-1 mapping between domains and clusters. &nbsp;The domain name and the cluster name are the same. &nbsp;&nbsp;</p> <p>As with current instances with a RuntimeType of INSTANCE, the data for the instance is stored in the <em>nodes</em> directory structure. Typically, this directory structure is found under <em>as-install</em>/glassfish/nodes, but the directory structure may be elsewhere as indicated by the --nodedir option for various commands. As with other instances that are created on the localhost, the default node name for instances in a user-managed cluster is localhost-<em>domainname</em>, e.g., if a user-managed cluster name is "cluster1", then the domain name is also "cluster1" and the node name for instances in that cluster by default is "localhost-cluster1". &nbsp;Since there is no DAS, the node directory structure for a user-managed cluster node does not contain an "agent" subdirectory nor does it have a das.properties file. Thus, the software can distinguish between a node directory for DAS-managed instances and one for user-managed cluster instances based on the presence of an agent subdirectory or the das.properties file. &nbsp; &nbsp;</p> <p>This feature does not guarantee that the configuration for instances in a cluster stays in sync with each other. &nbsp;It is the responsibility of the user or software provided by the user to do this. &nbsp;When GlassFish instances communicate with one another, the software must handle potential errors caused by having configuration data, including the list of deployed applications, that is not in sync.&nbsp;</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ConfigurationchangestoremoveisDas%28%29calls"></a>Configuration changes to remove isDas() calls</h2> <p>The usages of isDas() are quite numerous and varied.<br> Most of the isDas() calls do not apply to a user-managed instance. For these cases we could</p> 
     <ol> 
      <li>Remove isDas() and replace with a new global configuration attribute.</li> 
      <li>Remove isDas() and replace with a new configuration attribute for the specific question being asked.</li> 
      <li>Keep isDas() as it is.</li> 
     </ol> <p>Option 2 would introduce too many new configuration attributes because the usages are so many and varied.<br> Option 3 would require no change.</p> <p><b>Decision</b>: use option 3 for this</p> <p>For the isDas() calls that do apply to a user-managed instance, we could</p> 
     <ol> 
      <li>Add a new method isUserManaged() to ServerEnviromentImpl and a new RuntimeType.USER_MANAGED.</li> 
      <li>Add a new global configuration attribute or property 
       <ol> 
        <li>Use the existing admin-service type attribute, adding a new pattern for user-managed-instance. 
         <div class="code panel" style="border-width: 1px;">
          <div class="codeContent panelContent"> 
           <div id="root"> 
            <pre class="theme: Confluence; brush: java; gutter: false">@Attribute (defaultValue="server")
    @Pattern(regexp="(das|das-and-server|server)")
    String getType();</pre> 
           </div> 
          </div>
         </div></li> 
        <li>Add a new attribute, such as "type" or "enable-admin", to server or server-config.</li> 
       </ol> </li> 
      <li>Add specific configuration attributes for each type of question asked, such as 
       <ol> 
        <li>enable-gms</li> 
        <li>enable-auto-deployer</li> 
        <li>generate-artifacts</li> 
        <li>enable-admin</li> 
        <li>enable-admin-console</li> 
        <li>collect-log-files</li> 
        <li>enable-java2db</li> 
        <li>enable-full-access</li> 
       </ol> </li> 
     </ol> <p>For Option 1 or 2, the code (not isDas()) would ask the question it wants the answer to. The RuntimeType or AdminService type defines the basic state of the server - such as whether it's user-managed or DAS-managed. &nbsp;Then the code can interpret those facts and draw conclusions based on those facts - such as whether to accept admin requests from non-DAS origins. &nbsp;This approach allows the config to remain more stable over time while over successive releases the code can make more and more sophisticated decisions based on that stable config, as needs dictate.&nbsp;</p> <p>Option 3 introduces probably at least 8 new attributes. (More if isDas() is removed completely for the cases where isDas() does not apply to user-managed instances). These 8 new attributes help to define the state of the server using a more fine-grained approach than Option 1 or 2. The attributes for DAS and a user-managed instance would be "true", whereas the attributes for a DAS-managed instance would be "false". The advantage is the flexibility to configure the system differently for its specific needs, but this flexibility and fine-grained approach may not really be needed. Also, in future releases, we may have to add more attributes for new features.</p> <p><b>Decision</b>: implement mainly option 2b, but with a slight variation. &nbsp;The Server config bean will be modified to have duck-typed methods that answer the various questions that are asked by the code, such as isAdminEnabled, generateArtifacts, etc. The implementation of these methods will use the type attribute for the &lt;server&gt; element to determine how to answer the question. &nbsp;Also, we will not implement admin console running on a user-managed instance.&nbsp;</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-AnalysisofisDas%28%29"></a>Analysis of isDas()</h3> <p><b>Cluster</b></p> <p>GetHealthCommand uses !env.isDas() to allow the command to run only on DAS. User-managed instance should be able to run get-health. The get-health command should be executed on those servers which have knowledge about all instances in a cluster, not just itself. A new duck-typed method on Server config is required: <font color="blue">isOmniscient</font></p> <p>Some commands (CreateInstanceCommand, ListInstancesCommand, RestartInstanceCommand, StartClusterCommand, StopInstanceCommand) use env.isDas() to allow the command to run only on DAS. No changes are required in the command. However, !env.isDas() could be removed because the command already has defined @ExecuteOn(RuntimeType.DAS). StartInstanceCommand and StopClusterCommand also use env.isDas() to only run on DAS. These could be replaced with @ExecuteOn(RuntimeType.DAS).</p> <p>SupplementalCommandExecutorImpl uses serverEnv.isDas(), serverEnv.isInstance(), and a command's RuntimeType to determine if the command can be executed. No change required.</p> <p><em>GMS</em></p> <p>GMSAdapterImpl uses isDas to initialize health history of the cluster. A user-managed instance may need to initialize the health history as well. Since the server needs the health history of all the instances in the cluster, the duck-typed method on Server config, <font color="blue">isOmniscient</font>, can be used. &nbsp;This method returns true when server type="das" or type="user-managed-instance", and false when server type="instance".</p> <p>GMSAdapterImpl uses isDas to determine the member type as spectator for DAS or core for non-DAS. No change required.</p> <p>GMSAdapterImpl uses isDAS to determine whether it is a bootstrapping node, where DAS is a bootstrapping node. A bootstrapping node refers to a node that was used to bootstrap finding the cluster when multicast is not enabled. This is currently not being used in 3.x. The isDAS call may not be the only way to determine if a self-managed member is considered a bootstrap node. But at this time we are not using the concept at all, so it is okay to just comment that info out and we will work on it when implementing non-multicast support. (from Joe F.)</p> <p>GMSAdapterService uses env.isDas() to determine whether to create a GMSAdapter for all clusters on DAS that have GMS enabled, or just for the cluster of the current instance. No change required.</p> <p>GMSAdapterServer uses env.isDas() in the config listener changed method, to have DAS join a gms-enabled cluster on create-cluster event, and to have DAS leave a gms-enabled cluster on delete-cluster event. This does not apply to user-managed instances. No changes required.</p> <p>HealthHistory uses server.isDas() to skip creation of health history for the DAS. No changes required.</p> <p><b>Config API</b></p> <p>Server uses env.isDas() during _unregister-instance to prepare information about the cluster for the supplemental command. No changes required.</p> <p>ConfigRefValidator uses server.isDas() to validate that config-ref for "server-config" cannot be changed on DAS, and no other config can use "server-config. No changes required.</p> <p>PortManager uses server.isDas() to help create the local server list. If the server is DAS, then we can add it to the serversOnHost list. No need to check if it's local. No changes required.</p> <p>ServerHelper uses server.isDas() and env.isDas() in the getAdminHost() method to return the admin host using System.getProperty("com.sun.aas.hostName"); if the server is DAS. No change required.</p> <p><b>Connectors</b></p> <p>Connector classes (and JDBCResourceManager) use isDas() to ask 'Does this server have information about all targets (clusters/instances)? If yes, then the code can check if a resource is referenced by more than one target. This is useful for validating if a resource may be deleted or not. A resource may not be deleted from a target, if it is also referenced by another target. This is also used in ConnectorRuntime so it can do a data source lookup on DAS.</p> <p>Since there is only one user-managed cluster per domain, there is only one target available, which is the user-managed cluster. These validations do not apply to a user-managed instance. No change required. However, isDas() could be removed, because when a resource is referenced by more than one target, the command fails on DAS and will never be replicated to any of the targets so the isDas() is not needed.</p> <p><b>Deployment</b></p> <p><em>Partial Deployment</em></p> <p>GlassFish 3.1 allows partial deployment in a cluster. Partial deployment means the deployment did not fully succeed, e.g. it failed loading on one or more instances and the application was not written to the instance's domain.xml. Deployment commands, DeleteApplicationRefCommand, DisableCommand, and UndeployCommand use isDas() to allow the clean-up of partial deployments, while also allowing the command to fail on the DAS if an application is not already registered on DAS. For example, if an application is partially deployed when a user runs delete-application-ref, the application is first removed successfully from the DAS domain.xml. Then on the instance where the application is not registered, isDas() prevents the command from failing on the instance and returns without trying to remove the application from domain.xml. In this case, isDas() is asking 'Should we fail this command if the application is not registered?'</p> <p>For a User-Managed instance, these commands should also fail if the application is not registered. <font color="blue">To allow the commands, DeleteApplicationRefCommand, DisableCommand, and UndeployCommand to fail, we can remove isDas() in the places where it is asking 'Should we fail this command if the application is not registered?' and add set the commands Failure Policy to Ignore if the command is being replicated.</font></p> <p>@ExecuteOn(...., ifFailure=FailurePolicy.Ignore, ...)</p> <p>This means all failures will be ignored when replicating this command.</p> <p><em>Replication</em></p> <p>Deployment classes use isDas() to determine whether to replicate a command. In this case, isDas(), is asking 'Can this server replicate commands?'. Replication does not exist in a User-Managed Cluster, so no code change is required here.</p> <p><em>DisableCommand</em></p> <p>DisableCommand uses isDas() to send an APPLICATION_DISABLED event on DAS so proper clean up can be triggered. The JPADeployer listens for the APPLICATION_DISABLED event, so it can close all the EntityManagerFactory(s) created for the application. A user-managed instance should also send an APPLICATION_DISABLED event so the EMFs can be closed by the JPADeployer. A new duck-type method on Server can be used <font color="blue">isJava2dbEnabled</font>, which returns true or false depending on the value of the new Server type attribute: das, instance, user-managed-instance.</p> <p><em>DeleteApplicationRefCommad</em></p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">if (server.isDas()) {
            commandParams.origin = Origin.unload;
        } else {
            // delete application ref on instance
            // is essentially an undeploy
            commandParams.origin = Origin.undeploy;
        }</pre> 
       </div> 
      </div>
     </div> <p>In this case, isDas() is asking 'Can this server manage applications it's not running?'. A User-Managed Instance does not manage applications it is not running. No change is required.</p> <p><em>AutoDeployService</em></p> <p>isDas() is used to only start the auto deployer if the server is DAS. isDas() is asking 'Should we enable the auto deployer?'. A user-managed instance may also want auto deployer to be started. <del>A new duck-typed method</del> <font color="blue"><del>isAutoDeployerEnabled</del></font> <del>on the Server config would be required. This would return true when server type="das" or type="user-managed-instance", false when type="instance".</del> The isDas() call was replaced with using the existing getAutodeployEnabled() on DasConfig of AdminService.</p> <p><b>EJB Container</b></p> <p><em>Deployment</em></p> <p>EjbContainerUtilImpl uses !isDas() to set _doDBReadBeforeTimeout = true. In this case, !isDas() is asking 'Is _doDBReadBeforeTimeout default true?' On a clustered instance, the default is true, so a user-managed instance default should also be true. No change is required.</p> <p>EjbContainerUtilImpl uses isDas() to ask 'Can this server manage applications it's not running?', and sets the origin deployment parameter accordingly to deploy or load. A user-managed instance does not manage applications it's not running. No change is required.</p> <p>EjbDeployer uses isDas() to ask 'Does this server need to be cleaned of any files and artifacts (CMP beans, timers) that were created during the execution of the prepare method?'. A user-managed instance may also need to be cleaned of files and artifacts. A new duck-typed method, <font color="blue">createsEjbFilesAndArtifacts</font>, can be added to EjbContainer config. This method returns true when server type="das" or "user-managed-instance",and false when type="instance".</p> <p>EjbDeployer uses isDas() to ask 'Does this server require EJB artifacts to be generated?' Currently, artifacts are only generated when being deployed on DAS. A user-managed instance may also want EJB artifacts to be generated. The new duck-typed method, <font color="blue">createsEJbFilesAndArtifacts</font>, could be used.</p> <p><em>Timers</em></p> <p>EJBTimerService uses </p>
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">!(deploy &amp;&amp; isDas())</pre> 
       </div> 
      </div>
     </div> during recoverAndCreateSchedules(..) and createSchedules(..) to ask 'Is this a clustered deployment?'. If this method is called on a deploy in a clustered deployment, only persistent schedule<br> based timers will be created. And no timers will be scheduled. If it is called from deploy on a non-clustered instance, both persistent and non-persistent timers will be created. Otherwise, only non-persistent timers are created by this method. A user-managed cluster can have a clustered deployment so non-persistent timers should not be created on clustered deploy of a user-managed instance either. Since the negative is used '!', no change is required to allow the same behavior on a user-managed instance.<p></p> <p>DistributedEJBTimerServiceImpl uses !isDas() to ask 'Is the server required to 1) register for Planned Shutdown event, 2) set DB read before timeout to true, 3) register for transaction recovery events?'.<br> A user-managed instance may require the above steps as well. No change is required, to allow the same behavior on a user-managed instance.</p> <p><em>Distributed</em></p> <p>ReadOnlyBeanMessageCallBack uses !ejbContainerUtil.isDas() to ask 'Does this server require to 1) register as GMS adapter Message Listener 2) set as DistributedReadOnlyBeanNotifier ?'.<br> A user managed-instance is a clustered instance, so it also requires these actions.<br> No change is required to allow the same behavior on a user-managed instance.</p> <p><b>JMS</b></p> <p>JMSDestination uses isDas() to help determine the CommandTarget type: CONFIG, DAS, STAND_ALONE_INSTANCE, CLUSTER. If the CommandTarget is DAS, the default address list is used as the connection URL to get configured instance of MQ-RA, which is then used to obtain the JMXServiceURL/JMXServiceURLList.</p> <p>A user-managed instance would be similar to a target of clustered instance so no change necessary.</p> <p>JMSPing uses !targetServer.isDas() to ask 'Is this server a stand-alone or clustered instance?' If yes, then get the JMS host and port. No change is required, but !targetServer.isDas() could be replaced with targetServer.isInstance().</p> <p>JMSConfigListener uses thisServer.isDas() to ask 'Does this server not need to update the cluster broker list on the active JMS resource adapter when there is a config change event on the Server config?'<br> No change is required to allow the same behavior for a user-managed instance.</p> <p>MQAddressList uses isDAS(targetName) to ask 'Does this server require the default setup to concatenate all JMSHosts in a JMSService to create the address list?'. A user-managed instance would use the setup for clusters. No change required.</p> <p><b>Kernel</b></p> <p><em>CommandRunnerImpl</em></p> <p>CommandRunnerImpl uses env.isDas() to validate the command target types. Since a user-managed instance can execute a command, it should also validate the command target types. A new duck-type method on AdminService config is required: <font color="blue">isFullAccessEnabled</font>.</p> <p>CommandRunnerImpl uses env.isDas() to check that the server matches if the RuntimeType is DAS, or the command target is DOMAIN. A user-managed instance would run the command for serverEnv.isInstance() &amp;&amp; runtimeTypes.contains(RuntimeType.INSTANCE). No change required.</p> <p>CommandRunnerImpl uses env.isDas() to ask 'Does this server require replication?'. A user-managed instance does not require replication. No changes required.</p> <p><em>DyanmicInterceptor</em></p> <p>DynamicInterceptor uses MbeanService.getInstance().isDas() to add "server" as a target. No change required.</p> <p><em>StopDomainCommand</em></p> <p>StopDomainCommand uses !env.isDas() to fail the stop-domain command if it's not run on DAS. stop-domain should also fail on a user-managed instance. No change required.</p> <p><em>AdminConsoleAdapter</em></p> <p>AdminConsoleAdapter uses !env.isDas() to return if it's not running on DAS. Admin Console will not run on a user-managed instance, so no change is required.</p> <p><em>ApplicationConfigListener</em></p> <p>ApplicationConfigListener uses server.isDas() to help determine if the current instance matches the target. No change required.</p> <p><em>ApplicationLifecycle</em></p> <p>ApplicationLifecycle uses env.isDas() to set the target to "server" if the target is "domain" and we are running in DAS.<br> No change required.</p> <p>ApplicationLifecycle uses env.isDas() to load system applications on DAS. A user-managed instance does not have system applications. No change required.</p> <p><em>ApplicationLoaderService</em></p> <p>ApplicationLoaderService uses env.isDas() to load system applications on DAS. A user-managed instance does not have system applications. No change required.</p> <p>ApplicationLoaderService uses env.isDas()to (partially) load the application on DAS so the application information is available on DAS. No change required.</p> <p>ApplicationLoaderService uses env.isDas() to send a disable event on the DAS when the application is not loaded on DAS. A user-managed instance should also send a disable event. Then on the disable event, the EntityManagerFactory(s) can be closed by the JPADeployer. The new duck-typed method, <font color="blue">isJava2dbEnabled</font> can be used.</p> <p><em>AppServerStartup</em></p> <p>AppServerStartup uses env.isDas() during shutdown to execute stop-domain for DAS, and _stop-instance for non-DAS. A user-managed instance would require _stop-instance. No changes required.</p> <p><b>Logging</b></p> <p>LogManagerService, DeleteLogLevel, ListLogAttributes, ListLoggerLevels, SetLogLevel, and LogFilter use isDas() to get/delete/update the DAS logging properties. The logging.properties for a user-managed instance is in the same location for a DAS-managed instance: AS_INSTALL\nodes\nodename\instancename\config\instancename-clustername\logging.properties. No changes required.</p> <p>CollectLogFiles uses targetServer.isDas() to determine how to collect the log files for DAS. The targetServer.isInstance() is used to collect log file for a stand-alone instance. The 'else' condition collects log files for a cluster. A user-managed cluster can be a target of collect-log-files, not a user-managed instance. No change required.</p> <p>LogFilter uses targetServer.isDas() to determine how to get the log records and where to store them. It's used by Admin Tool Log Viewer Front End to filter the records. A user-managed instance will not have Admin Console running it so no change is required.</p> <p><b>Monitoring</b></p> <p>MonitoringReporter (get command) uses isDas() to determine whether to run locally and how to build the pattern. No change needed if the get command also runs locally on a user-managed instance and follows the same dotted pattern as a DAS-managed instance.</p> <p><b>Persistence</b></p> <p>JPADeployer uses isDas() in multiple places to ask 'Does this server execute java2db?'. If yes, the following type of actions are performed.</p> <p>1) execute java2db on DAS<br> 2) create EntityManagerFactory(EMF)s for java2db when deploying or enabling an app on DAS<br> 3) drop tables on undeploy</p> <p>If user-managed instance needs to do these actions as well, a new duck-typed method on Server config is required, such as, <font color="blue">isJava2dbEnabled</font>.</p> <p><b>Security</b></p> <p><em>CreateFileUser</em></p> <p>CreateFileUser uses isDas() to ask 'Should we fail this command when there is a BadRealmException that is not due to a user already existing in a shared keyfile?'.<br> In a clustered setup, when a file realm is created, the keyfile is shared among all the instances, since the user created for a cluster should be available for all the instances within it. However, when a file user is created for the cluster, the command is replicated to all the instances. Since the keyfile is shared by the instances, a BadRealmException could be thrown in all the instances since the user already exists in the shared keyfile (user was already created by DAS). The isDas() check is used to ignore the BadRealmException on the instances.</p> <p>In case of the user-managed instances (without a DAS), if the keyfile is shared, as in the previous case, no error would be thrown in the first instance where the command is executed. However we could afford to ignore the error for all the other user-managed instances. However we cannot be sure how to identify the first case of execution and not ignore the error.</p> <p>For a user-managed instance it cannot ignore the BadRealmException. If create-file-user is run on a user-managed instance, it will not be replicated to the other instances because replication doesn't exist in user-managed clusters. If the user tries to run create-file-user on a second user-managed instance, they would get the error if the user has already been created in the shared keyfile. A new duck-type method on ? config is required, <font color="blue">?</font> .</p> <p><em>AdminAdapter</em></p> <p>AdminAdapter uses !env.isDas() during admin request authentication to ask 'Is it ok to invoke req.getUserPrincipal() to get the SSL Principal?'.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">final Principal sslPrincipal = ! env.isDas() ||
                    Boolean.getBoolean(DAS_LOOK_FOR_CERT_PROPERTY_NAME) ? req.getUserPrincipal() : null;
            return authenticator.loginAsAdmin(user, password, as.getAuthRealmName(),
                    req.getRemoteHost(), authRelatedHeaders(req), sslPrincipal);</pre> 
       </div> 
      </div>
     </div> <p>A user-managed instance will also invoke req.getUserPrincipal(). Also, with more recent changes to Grizzly, this check is going to be removed by another project. No change required.</p> <p>AdminAdapter uses env.isDas() to determine which authorization failure to report during authentication when access is NONE.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">if (env.isDas()) {
                    reportAuthFailure(res, report, "adapter.auth.userpassword",
                        "Invalid user name or password",
                        HttpURLConnection.HTTP_UNAUTHORIZED,
                        "WWW-Authenticate", "BASIC");
                } else {
                    reportAuthFailure(res, report, "adapter.auth.notOnInstance",
                            "Configuration access to an instance is not allowed; please connect to the domain admin server instead to make configuration changes",
                        HttpURLConnection.HTTP_FORBIDDEN);
                }</pre> 
       </div> 
      </div>
     </div> <p>A user-managed instance should also report the same authorization failure as DAS when access is NONE. A new duck-typed method on AdminService config is required: <font color="blue">isFullAccessEnabled</font>.</p> <p><em>GenericAdminAccessController</em></p> <p>The GenericAdminAccessController.chooseAccess method grants Access.FULL to a server only if serverEnv.isDas is true. This will be changed to use a <font color="blue">isFullAccessEnabled</font> duck-typed method on AdminService config. This method returns true when Server type="das" or type="user-managed-instance", and false when type="instance".</p> <p><em>GenericAdminAuthenticator</em></p> <p>GenericAdminAuthenticator uses serverEnv.isDas() to return the access to be granted the authenticated user. If the current node is not the DAS, then we grant only monitoring access. 3.1 does not permit full admin access to instances. If the current node is the DAS, then we grant full admin access only if the request came from the same host or if secure admin is enabled.<br> A user-managed instance will need full access like the DAS. A new duck-typed method, <font color="blue">isFullAccessEnabled</font> on AdminService, is required.</p> <p>The GenericAdminAuthenticator.authenticateAsTrustedSender method is only used for communication between a DAS and an instance, so this would never be used for the user-managed cluster case.&nbsp; So the call to isDas at line 312 doesn't need to be changed, and there doesn't have to be any configuration changes related to this.</p> <p>ServerRemoteAdminCommand uses serverEnv.isDas() in the getCertAlias() method to determine how to get the appropriate alias for the DAS or the instance. The default alias for DAS is "s1as". The default alias for non-DAS is "glassfish-instance". No changes required.</p> <p>ResourceUtil uses server.isDas() in getTargetsReferringResourceRef(String refName) to add DAS to the list of targets if DAS also has the specified resource ref. No change required.</p> <p><b>Web Services</b></p> <p>MetroContainer uses isDas() in deployWsTxServices(String target) to ask 'Does this server manage applications it's not running?'. The deployment parameters, origin and target, are set accordingly.<br> A user-managed instance does not manage applications it's not running. No change is required.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-AnalysisofisInstance%28%29"></a>Analysis of isInstance()</h3> <p>CommandThreadPool uses serverEnv.isInstance() to check if it is not DAS and to return without creating the command pool for executing commands. A user-managed instance can execute commands so it would also need the command pool. The new duck-typed method on AdminService <font color="blue">isFullAccessEnabled</font>, may be used.</p> <p>RestAdapter uses serverEnvironment.isInstance() to only allow GET requests on an instance that is not DAS, and returns a FORBIDDEN error for other requests. A user-managed instance should be allowed SET requests, same as DAS. The new duck-typed method on AdminService, <font color="blue">isFullAccessEnabled</font>, may be used.</p> <p>StopInstanceInstanceCommand (_stop-instance) and RestartInstanceInstanceCommand (_restart-instance), which is called by stop-local-instance and restart-local-instance, uses !env.isInstance() to only allow the command to be executed on a DAS-managed instance. This validation can be removed, since the class has already defined @ExecuteOn(RuntimeType.INSTANCE). _stop-instance needs to also be allowed to run on a user-managed instance. Since RuntimeType.INSTANCE includes both DAS and user-managed instances, no change is required.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-CommandChanges"></a>Command Changes</h2> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-GeneralDASonlyasadminCommandChanges"></a>General DAS-only asadmin Command Changes</h3> <p>Look at DAS-only @ExecuteOn for asadmin commands to see which ones apply for the new instance type (D: Chris)</p> <p><a href="http://wikihome.us.oracle.com/jesarch/Wiki.jsp?page=GFExecuteOnUsage">ExecuteOn Usage</a></p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-SpecificExistingCommandChanges"></a>Specific Existing Command Changes</h3> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-LocalInstanceCommands"></a>Local Instance Commands</h4> <p>Several commands for managing local instances in 3.1 are modified to support additional options to support user-managed cluster instances. &nbsp;</p> <h5><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-createlocalinstance"></a>create-local-instance</h5> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p>Usage: create-local-instance<br> &nbsp;&nbsp;&nbsp;&nbsp;[--node &lt;node_name&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nodedir &lt;node_path&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--savemasterpassword]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--usemasterpassword]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--config &lt;config_name&gt; | --cluster &lt;cluster_name&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--systemproperties (name=value)[:name=name]*]<br> &nbsp; &nbsp; [--portbase &lt;portbase&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--checkports]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--lbenabled]<br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--usermanaged]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--template &lt;template&gt;]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--keytooloptions &lt;keytooloptions&gt;]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--savelogin]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--nopassword]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;instance_name</p> 
      </div>
     </div> <p>The create-local-instance command can create three types of local instances: DAS-managed clustered instance, DAS-managed standalone instance, and a user-managed instance. &nbsp;The command determines what type to create based on the arguments that are passed in. &nbsp;The --usermanaged option is there to allow the command to make the determination when the other options cannot be used to determine what to do. &nbsp;When using the options that were available in 3.1, then the behavior of the command is the same as in 3.1.&nbsp;</p> <p>The following combinations of options are invalid:</p> 
     <ul> 
      <li>--config with any of the options that request a user-managed instance</li> 
      <li>If --usermanaged or any of the other new properties are specified, then --cluster is required</li> 
     </ul> <p>If any of the new options are specified, then the request is for a user-managed instance.</p> <p>When a user-managed instance is to be created, the command operates as a completely local command; not as a hybrid command as is the case for DAS managed instances. Creating a user-managed instance consists of the following steps:</p> 
     <ol> 
      <li>create the node directory, if necessary</li> 
      <li>create a directory for the instance (check to see if the instance name conflicts with existing instance names in for that node)</li> 
      <li>create the domain.xml based on a "user-managed-instance.xml" template from the glassfish/lib/templates directory. (see below for details on this template)</li> 
      <li>create the remaining files for the instance (keystores, logging.properties, etc.)</li> 
     </ol> <p>The instance that is created has GMS disabled. To enable GMS, the instance has to be started and appropriate commands executed to configure and start GMS.</p> <p>As with the create-domain command, when creating a user-managed instance, create-local-instance will prompt for the asadmin password or will accept it in the password file using AS_ADMIN_ADMINPASSWORD.</p> <h6><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-usermanagedinstance.xmlTemplate"></a>user-managed-instance.xml Template</h6> <p>The user-managed instance is created from a template file called user-managed-instance.xml. &nbsp;This template contains a single &lt;config&gt; element that is similar to the "default-config" that is currently in the domain.xml template. &nbsp;It contains a single &lt;server&gt; element named with the instance name. &nbsp;It contains a single &lt;cluster&gt; element named with the cluster/domain name. The new template also contains configuration information needed to allow the instance to process asadmin commands (see the previous section about isDas() calls).</p> <p>The user-managed-instance.xml template depends on the use of system property substitution to set port numbers, just like the current "default-config" does. &nbsp;Thus, there is no --domainproperties option like there is with create-domain. &nbsp;Rather, port numbers must be set using the --systemproperties option.&nbsp;</p> <h5><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-deletelocalinstance"></a>delete-local-instance</h5> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p>Usage: delete-local-instance<br> &nbsp;&nbsp;&nbsp;&nbsp;[--node &lt;node_name&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nodedir &lt;node_path&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--cluster &lt;cluster_name&gt;]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;instance_name</p> 
      </div>
     </div> <p>The delete-local-instance command uses either the --cluster or the --node and --nodedir options to find the filesystem information for the instance. &nbsp;The --cluster option is not strictly necessary, because the user could just specify the node, but by providing the --cluster option, then the user does not have to deal with nodes when working with user-managed clusters.</p> <p>The delete-local-instance command determined whether the instance is DAS-managed or user-managed based on the presence of the das.properties file. &nbsp;If it is a user-managed instance, then the command just removes the filesystem information for the instance after verifying that the instance is stopped. If this is the last instance using the node directory structure, then that directory structure is also removed.&nbsp;</p> <h5><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-startlocalinstance"></a>start-local-instance</h5> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p>Usage: start-local-instance<br> &nbsp;&nbsp;&nbsp;&nbsp;[--verbose]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--debug]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nosync]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--syncfull]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--node &lt;node_name&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nodedir &lt;node_path&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--cluster &lt;cluster_name&gt;]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;instance_name</p> 
      </div>
     </div> <p>As with delete-local-instance, the start-local-instance&nbsp;command uses either the --cluster or the --node and --nodedir options to find the filesystem information for the instance. &nbsp;It determines if the instance is user-managed, and if so, it skips the synchronization step with the DAS. &nbsp;Then it behaves just as start-local-instance does in 3.1.</p> <h5><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-stoplocalinstance"></a>stop-local-instance</h5> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p>Usage: stop-local-instance<br> &nbsp;&nbsp;&nbsp;&nbsp;[--node &lt;node&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nodedir &lt;nodedir&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--force]<br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--cluster &lt;cluster_name&gt;]</b><br> instance_name</p> 
      </div>
     </div> <p>As with delete-local-instance, the stop-local-instance&nbsp;command uses either the --cluster or the --node and --nodedir options to find the filesystem information for the instance. &nbsp;Then it behavior just as stop-local-instance does in 3.1.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Deploy"></a>Deploy</h4> <p>Figure out how deploy and _deploy can be merged, and how the extra options for first/last instance (D: Rajiv)</p> <p>Need to make sure that stuff that happens only on DAS only happen in one instance (e.g., creating a database instance) (D: Rajiv)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-listcommandsCommand"></a>list-commands Command</h4> <p>The list-commands command will be modified so that it only returns the list of commands that can actually be executed on the instance. It will do this by examining the @ExecuteOn annotation that is associated with the command and comparing the value of the annotation with the RuntimeType of the server. &nbsp;Commands that do not include the current RuntimeType of the server in the @ExecuteOn annotation will be excluded from the list that is returned by the command.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-createserviceCommand"></a>create-service Command</h4> <p>Need to modify create-service to support the new instance type (P3) (D: Jennifer)</p> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p>Usage: create-service<br> &nbsp;&nbsp;&nbsp;&nbsp;[--name service-name]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--serviceproperties service-properties]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--dry-run={false|true}]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--force={false|true}]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--serviceuser service-user]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--domaindir domain-dir]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--nodedir node-dir]<br> &nbsp;&nbsp;&nbsp;&nbsp;[--node node]<br> &nbsp;&nbsp;&nbsp;&nbsp;<b>[--cluster &lt;cluster_name&gt;]</b><br> &nbsp;&nbsp;&nbsp;&nbsp;[domain-or-instance-name]</p> 
      </div>
     </div> <p>As with delete-local-instance, the create-service&nbsp;command uses either the --cluster or the --node and --nodedir options to find the filesystem information for the instance. &nbsp;Then it behaves just as create-service does in 3.1. If multiple node directories exist, the node or cluster option must be specified. The user-managed instance must be specified as the operand.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-NewCommands"></a>New Commands</h3> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ListingLocalInstances"></a>Listing Local Instances</h4> <p>list-local-instances (local command to list instance in local instances dir - like list-domains) (D: Tom)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Backup%2FRestore"></a>Backup/Restore</h4> 
     <ul> 
      <li>backup-local-instance (P3)</li> 
      <li>restore-local-instance (P3)</li> 
     </ul> <p>Backup for an instance has to be implemented (P3) (D: Chris)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-SecurityChanges"></a>Security Changes</h2> <p>The changes required for security are describe in the section for <b>Configuration change to remove isDas() calls</b></p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ContainerIssues"></a>Container Issues</h2> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ApplicationId"></a>Application Id</h3> <p>As part of high availability of stateful session beans, the application id's that are generated at deployment, of stateful session beans the application id needs to be the same across the cluster. Today the application id is generated by using the System.currentTimeMillis() and then replicated by the DAS to the cluster deployment. <br class="atl-forced-newline"> However as we move to the user managed cluster design approach, since the deployment will be done on each unmanaged instance, we need to ensure that the app id continues to be the same on all the instances. To make it happen, the generation of application id needs to change from using System.currentTimeMillis(). As part of the change, one way to ensure the same id is generated is to use MD5 hash of the application to generate the application id. <br class="atl-forced-newline"> A corner case today is that at redeployment, even if the application has not changed, a new application id is generated. With the MD5 Hash approach, if the application has not changed, but for some reason the application has be redeployed, the application id will remain the same. Details of why the application id needs to change on redployment still needs to be discussed. However except for this corner case, the MD5 hash should work for most cases. We will base the solution on MD5 Hash with some changes to address the corner case described above.</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Timers"></a>Timers</h3> <p>Look at migrate timers (D: Chris)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Transactions"></a>Transactions</h3> <p>and transactions (D: Chris)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-ClusteringforJMS%2FMQ"></a>Clustering for JMS/MQ</h2> <p>Work with JMS/MQ team as to how JMS cluster will work with this feature (D:Chris)</p> <h4><a name="GlassFishUser-ManagedClustersDesign-take1%28obsolete%29-Upgrade"></a>Upgrade</h2> <p>This section describes the changes needed in the upgrade logic as a result of this design.&nbsp;</p> 
     <ol> 
      <li>The admin-service enable-full-access attribute needs to be set to "true" for the server-config.</li> 
     </ol> </td> 
   </tr> 
  </tbody>
 </table>    
</body></div>
        <br/>

        <!-- footer================================================== -->
        <footer class="well">
            <div class="container">

                <div class="row-fluid" id="bottom-info">
                    <!--div class="span6 pagination-centered" id="social"-->
                    <div class="span4" id="social">			
                        <a href="http://blogs.oracle.com/theaquarium/"><img src="../images/icons/TheAquarium.png"></a>
                        <a href="https://twitter.com/glassfish"><img src="../images/icons/twitter.png"></a>
                        <a href="https://plus.google.com/communities/106098646151660933759"><img src="../images/icons/google.png"></a>
                        <a href="http://www.linkedin.com/groups/GlassFish-Users-106819/about"><img src="../images/icons/linkedin.png"></a>
                        <a href="http://www.youtube.com/user/GlassFishVideos"><img src="../images/icons/youtube.png"></a>
                        <a href="https://www.facebook.com/GlassFish"><img src="../images/icons/facebook.png"></a>
                    </div>

                    <div class="span8" id="copyright">Page last changed on Jun 27, 2011 by 
<font color="#0050B2">trmueller</font>. Exported from wikis.oracle.com on May 27, 2015 20:47.<br/>
                        Copyright &copy; 2005-2015 Oracle Corporation and/or its affiliates.</div>
                </div>
            </div>
        </footer>

        <!-- ================================================== -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/bootstrap-tab.js"></script>
	<script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<!--  Begin SiteCatalyst code  -->
  	<!--  End SiteCatalyst code  -->
    </body>
</html>