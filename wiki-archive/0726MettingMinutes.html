<!DOCTYPE html>
<html  xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>GlassFish Wiki : 0726MettingMinutes</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="" />
        <meta http-equiv="content-language" content="en" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap.min.css" rel="stylesheet" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
        <link href="styles/docs.css" rel="stylesheet" />
        <link href="styles/site1.css" rel="stylesheet" />
        <style> a { color: #555555; } </style>
        <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body class="page-documentation project-gfmvnsite" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

        <div class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <div class="brand"><a href="/glassfish/index.html"><img src="../images/gflogo24.png"><span style="color:#E88A43;font-size:18px;padding-left:11px;padding-top:15px;font-weight:bold;">GlassFish</span> - <span style="font-size:18px;" class="gf-grey">World's first Java EE 7 Application Server</span></a></div>
                    <div class="nav-collapse">
                        <ul class="nav pull-right">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                                <ul class="dropdown-menu">
									<li><a href="/glassfish/LICENSE" title="License">Legal </a></li>
									<li><a href="/glassfish/CONTRIBUTING" title="Contributing">Contributing </a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><!--/.nav-collapse -->
                </div>
            </div>
        </div>

        <br/><br/>
        <div class="container"><body> 
 <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff"> 
  <tbody>
   <tr> 
    <td valign="top" class="pagebody">   <h4><a name="0726MettingMinutes-MinutesofmeetingLBteam20070626"></a>Minutes of meeting LB team 2007-06-26 </h2> <p>Minutes of meeting LB team 2007-06-26 </p> <p>Larry is worried about the overall latency requirements (see Larry's email). Specifically: </p> 
     <ul> 
      <li>waiting for ack is expensive, so we should explore whether we really want to avoid replication failures and to what cost.</li> 
     </ul> 
     <ul> 
      <li>moving active objects is expensive, so we should try to see if we can have an architecture where we can keep ongoing sessions sticky once they have moved, but still route new sessions to new/restored node.</li> 
     </ul> <p>The GMS distributed hash can be used to provide an override mechanism for ongoing (sticky) sessions. </p> <p>Migrating active sessions </p> <p>After some discussion on how data/user centric routing works the tentative conclusion is that we probably can not implement the proposal from Larry/Jan since the LB can not see if the request is for a new session of for an ongoing session. It is the application that decides this in the @SipApplicationKey method and it depends on the fact whether the SAS for the key generated by this method is already in progress or not.</p> <p>So (in my personal interpretation) this would mean that in the LB we would have to somehow map hashkeys to SASids and have some sort of feedback (via the hashmap) of all the still ongoing sip application sessions on the 'failover node'. Only once an ongoing session has stopped (e.g., based on timeout of the SAS) would the new requests with this hashkey be routed to the restored node. This does not seem really feasible to me, but the LB team will investigate whether there is some equivalent solution. </p> 
     <ul> 
      <li>Reply by Joel on 072707 10:08 CET: Yes, we will look into it and see what can be done. I envision something like that if a certain hash key value has been tied to a session which is found to have been migrated, then that specific hash key value will be sticky to a certain AS instance instead of be used as input to consistent hashing. There is one corner case here though. What if at a later point (remember that sessions can last for days in the presence application), the second AS instance fails? 
       <ul> 
        <li>Reply by Erik van der Velden on 072707 15:59 CET: I do not get this. At the failover you would have to know which hashkeys refer to ongoing sessions on the failed node. As you mentioned in another mail, there will be relation between the session replication framework, the semantics of the replicated items (sip application session id) and the relation with the hashkey. This would be quite difficult to achieve. And how would you eventually go back to the normal situation, which would mean that you have to remove those hashkeys from your 'consistent hash exclusion table' when the corresponding sip application session is invalidated. If you never remove any items from the exclusion table, then it would grow at each failover, leading to an unbalanced load and potential problems with multiple failures. 
         <ul> 
          <li>Reply by Joel on 072707 16:53 CET: As I said, We shall see what can be done. This was just a rough idea, it might not be a feasible solution at all.</li> 
         </ul> </li> 
       </ul> </li> 
     </ul> <p>If we assume that the migration of active sessions is needed we have two choices </p> 
     <ul> 
      <li>a forced migration (called backflush by Larry). This might be tricky since you have to know which part of the data to 'flush back'.</li> 
     </ul> 
     <ul> 
      <li>a lazy migration based on incoming request routed by the LB to the restored node.</li> 
     </ul> <p>The latter would probably already work. Any session that did fail over during the time the node was down will have become active on another instance and (this is important) would have created a replica with the same version as the result of a load request on the failover node. When the LB routes requests in the session back to the restored node the load request will active the session in the restored node based on the load request. The last replica would be removed and a new replica would be made. This is all part of the current replicaiton framework. </p> <p>The only drawback is that the previous active version of the data is not removed during the second load request. However, the embedded version information will ensure that that active version becomes stale. </p> 
     <ul> 
      <li>Reply by Joel on 072707 10:08 CET: One caveat though: timers will still be active for it. Thus, it is possible that a timer fires in this stale version and the application is invoke and does something causing the session to be mutated and suddenly this instance is the latest version! 
       <ul> 
        <li>Reply by Erik van der Velden on 072707 15:59 CET: Correct. I forgot about this. This is the primary reason why you want to avoid this. The other drawbacks mentioned below are just secondary.</li> 
       </ul> </li> 
     </ul> <p>This should work in most situations, but has two drawbacks: </p> 
     <ul> 
      <li>some additional data is kept on the system that is superfluous.</li> 
      <li>some request for the data can not detect the staleness of the data due to the fact that there is no version information in the request (e.g., if requested by the utils.)</li> 
     </ul> <p>It was suggested by Ericsson that we could remove any (duplicate) active session during the load request, just as all replicas are removed to avoid these two problems.</p> <p>With the suggested solution active session migration might be possible, but still the impact on latency etc has to be investigated and any alterantive solution that avoids the migration should be explored. </p> 
     <ul> 
      <li>Reply by Joel on 072707 10:08 CET: As I commented to your previous mail. It struck me that we might not be able to migrate active sessions, since that must be treated as a session invalidation on the node where it going to be deleted. According to JSR-289 (section 6.1.2.2.2) it is not allowed to invalidate a SipApplicationSession until all protocol sessions have been invalidated and for SIP that means that all ongoing transactions must have finished. This can be really tricky! 
       <ul> 
        <li>Reply by Erik van der Velden on 072707 15:59 CET: I do not see what migration has to do with invalidation. You need to call sessionWillPassivate() on the old one and sessionDidActivate() on the new one. You move including any protocol session children. There is the question of concurrent access that plays an important role during migration. What if at the moment of migration, because a new request is routed to the restored instance, something is still accessing the session on the failover instance. We should wait until the doXXX() returns before migrating the session in that case, I guess (this locking issue is another reason to avoid migration). 
         <ul> 
          <li>Reply by Joel on 072707 16:53 CET: Yeah, you are right about that in regard to informing the application. But I think the JSR-289 is a little but confusing about this (6.4.3 and 6.2.4.1). I don't know if they have thought about this in JSR-289. I mean, they have specified some support for distributed systems in section 6.4.3, but I beleive they have not thought about ongoing transactions. If you migrate a SipApplicationSession containing SipSessions which have ongoing transactions the related transactionm must be removed as well and the transaction will be lost (maybe that is acceptable and then this is not a problem). 
           <ul> 
            <li>Reply by Joel on 072707 17:39 CET: After thinking of it a bit more, I have come to the conclusion that it should be acceptable to lose your transactions at recovery. I mean, we do not give any guarantees that transactions are kept when a node fails, consequently it should be OK to not guarantee that transactions are kept at recovery after fail-over.</li> 
           </ul> </li> 
         </ul> </li> 
       </ul> </li> 
     </ul> <p>Access via the SipSessionsUtil </p> <p>The SipSessionUtil allows access to the SipApplicationSession using the SASid that is obtained in any way (out-of-band).</p> <p>This can be used to access the SAS from, e.g., an EJB. </p> <p>It is impossible to route the requests in such a way that these request only occur on the instances where the SAS is already available.</p> <p>There are several possibilities: </p> 
     <ul> 
      <li>The data is access remotely</li> 
      <li>The active session is migrated to the node where the request is done (and migrated back when normal traffic occurs on the session).</li> 
     </ul> 
     <ul> 
      <li>We simply do not comply to the spec, e.g., we do not guarantee that the correct session is returned, or that a session is returned at all.</li> 
     </ul> <p>If we decide to implement this we also have to think on how to accomplish locking semantics, which makes it even more tricky.</p> </td> 
   </tr> 
  </tbody>
 </table>    
</body></div>
        <br/>

        <!-- footer================================================== -->
        <footer class="well">
            <div class="container">

                <div class="row-fluid" id="bottom-info">
                    <!--div class="span6 pagination-centered" id="social"-->
                    <div class="span4" id="social">			
                        <a href="http://blogs.oracle.com/theaquarium/"><img src="../images/icons/TheAquarium.png"></a>
                        <a href="https://twitter.com/glassfish"><img src="../images/icons/twitter.png"></a>
                        <a href="https://plus.google.com/communities/106098646151660933759"><img src="../images/icons/google.png"></a>
                        <a href="http://www.linkedin.com/groups/GlassFish-Users-106819/about"><img src="../images/icons/linkedin.png"></a>
                        <a href="http://www.youtube.com/user/GlassFishVideos"><img src="../images/icons/youtube.png"></a>
                        <a href="https://www.facebook.com/GlassFish"><img src="../images/icons/facebook.png"></a>
                    </div>

                    <div class="span8" id="copyright">Page last changed on Nov 18, 2011 by 
<font color="#0050B2">am74686</font>. Exported from wikis.oracle.com on May 27, 2015 20:48.<br/>
                        Copyright &copy; 2005-2015 Oracle Corporation and/or its affiliates.</div>
                </div>
            </div>
        </footer>

        <!-- ================================================== -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/bootstrap-tab.js"></script>
	<script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<!--  Begin SiteCatalyst code  -->
  	<!--  End SiteCatalyst code  -->
    </body>
</html>