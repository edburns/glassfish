<!DOCTYPE html>
<html  xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>GlassFish Wiki : Hyperjaxb3Reference</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="" />
        <meta http-equiv="content-language" content="en" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap.min.css" rel="stylesheet" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
        <link href="styles/docs.css" rel="stylesheet" />
        <link href="styles/site1.css" rel="stylesheet" />
        <style> a { color: #555555; } </style>
        <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body class="page-documentation project-gfmvnsite" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

        <div class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <div class="brand"><a href="/glassfish/index.html"><img src="../images/gflogo24.png"><span style="color:#E88A43;font-size:18px;padding-left:11px;padding-top:15px;font-weight:bold;">GlassFish</span> - <span style="font-size:18px;" class="gf-grey">World's first Java EE 7 Application Server</span></a></div>
                    <div class="nav-collapse">
                        <ul class="nav pull-right">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                                <ul class="dropdown-menu">
									<li><a href="/glassfish/LICENSE" title="License">Legal </a></li>
									<li><a href="/glassfish/CONTRIBUTING" title="Contributing">Contributing </a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><!--/.nav-collapse -->
                </div>
            </div>
        </div>

        <br/><br/>
        <div class="container"><body> 
 <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff"> 
  <tbody>
   <tr> 
    <td valign="top" class="pagebody">   <p><a href="Hyperjaxb3.html" title="Hyperjaxb3">Documentation</a> | <a href="" title="Hyperjaxb3Reference">Reference</a> | <a href="Hyperjaxb3Configuration.html" title="Hyperjaxb3Configuration">Configuration</a></p> <h4><a name="Hyperjaxb3Reference-Hyperjaxb3ReferenceDocumentation"></a>Hyperjaxb3 Reference Documentation</h1> <h4><a name="Hyperjaxb3Reference-Overview"></a>Overview</h1> <p>If you already use JAXB, you know how much easier does this great tool make the XML processing in Java. Few lines of code and your XML is turned into an object stucture which is much suitable for Java code than, for instance, DOM or SAX. And you can always turn your object structure back to XML with almoust zero effort.</p> <p>Generally speaking, there are two principal alternatives for using JAXB in your applications:</p> 
     <ul> 
      <li>You may start with existing classes and annotate them JAXB annotations.</li> 
      <li>You may also start with an XML schema and use the schema compiler (XJC) to compile it into a set of schema-derived classes.</li> 
     </ul> <p>Although the first method is very useful if you want to XMLize existing class hierarchies, the real power of JAXB lies in the second, schema-driven approach. In this case you do not write the code manually - you just provide the XML schema and let JAXB generate the code for you. Schema compiler will analyze the schema and generate the sources of Java classes that represent the XML content.</p> <p>These classes are called <em>schema-derived classes</em>. They are just normal POJOs (well, <em>almost</em>) and therefore quite easy to handle in Java code. At the same time schema-derived classes contain all the required JAXB annotations (generated by the schema compiler).</p> <p>Hyperjaxb3 takes you one step further. It makes schema-derived classes <em>persistable</em> with JPA (Java Persistence API), allowing for storing and querying your JAXB objects (instances of schema-derived classes) in a relational database.</p> <p>Now, if consider JAXB implementing the XML &lt;<del>&gt; objects connection and Hyperjaxb3 providing relational persistence (objects &lt;</del>&gt; RDB), you get the full <b>XML &lt;<del>&gt; objects &lt;</del>&gt; RDB trip</b>.</p> <h4><a name="Hyperjaxb3Reference-Missionstatement"></a>Mission statement</h2> <p>The goal of Hyperjaxb3 is to <b>provide schema-derived classes with JPA persistence</b>. Therefore the principal task of Hyperjaxb3 is to turn JAXB schema-derived classes into JPA <em>entity classes</em> so that JPA layer could persist them in a relational database.</p> <p>In order to achieve this goal, Hyperjaxb3 implements a JAXB plugin which augments or corrects the generated code so that the produced schema-derived classes become valid persistent entity classes.</p> <p>Technically, Hyperjaxb3 tasks are:</p> 
     <ul> 
      <li>Correct, adapt or wrap types and properties not supported by JPA.</li> 
      <li>Add the required properties (ex. identifier or version) and methods (collection setters, <tt>equals</tt>, <tt>hashCode</tt>) where necessary.</li> 
      <li>Generate the required ORM metadata - JPA annotations or XML mapping resources.</li> 
      <li>Allow to customize the generated ORM metadata.</li> 
     </ul> <h4><a name="Hyperjaxb3Reference-JAXBversusJPAHyperjaxb3ReferenceJAXBVersusJPA"></a><a href="Hyperjaxb3ReferenceJAXBVersusJPA.html" title="Hyperjaxb3ReferenceJAXBVersusJPA">JAXB versus JPA</a></h1> <h4><a name="Hyperjaxb3Reference-Generating%7B%7Bequals%7D%7Dand%7B%7BhashCode%7D%7Dmethods"></a>Generating <tt>equals</tt> and <tt>hashCode</tt> methods</h1> <p>Although this is not directly required by the JPA specification, it is still recommended to have correct implementations of <tt>equals</tt> and <tt>hashCode</tt> methods in entity classes. JAXB uses the <tt>equals</tt> and <tt>hashCode</tt> plugins from JAXB2 Commons Basic to generate these methods. These plugins generate <a href="http://commons.apache.org/lang/">Commons Lang</a>-style <tt>equals</tt> and <tt>hashCode</tt> methods. With Hyperjaxb3 you can configure, which equals and hash code builders will be used <b>TODO</b> (<tt>org.jvnet.jaxb2_commons.lang.builder.JAXBEqualsBuilder</tt> and <br> <tt>org.jvnet.jaxb2_commons.lang.builder.JAXBHashCodeBuilder</tt>) or turn off <tt>equals</tt> and <tt>hashCode</tt> generation off <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Generating%7B%7Bpersistence.xml%7D%7D"></a>Generating <tt>persistence.xml</tt></h1> <p>According to the entity packaging guidelines of the JPA specification, Hyperjaxb3 generates the <tt>persistence.xml</tt> which describes generated classes in a persistence unit. This allows easier usage of mapped classes - entity manager will pick up the classes automatically.</p> <p>Hyperjaxb3 generates the persistence unit in the <tt>META-INF/persistence.xml</tt> file in the target directory. You may configure an alternative location <b>TODO</b> if you wish.</p> <p>Persistence unit generated by Hyperjaxb3 simply lists classes which were made entities:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;persistence
    version="1.0"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://java.sun.com/xml/ns/persistence"&gt;
    &lt;persistence-unit name="org.jvnet.hyperjaxb3.ejb.tests.po"&gt;
        &lt;class&gt;org.jvnet.hyperjaxb3.ejb.tests.po.Items&lt;/class&gt;
        &lt;class&gt;org.jvnet.hyperjaxb3.ejb.tests.po.Items$Item&lt;/class&gt;
        &lt;class&gt;org.jvnet.hyperjaxb3.ejb.tests.po.USAddress&lt;/class&gt;
        &lt;class&gt;org.jvnet.hyperjaxb3.ejb.tests.po.PurchaseOrderType&lt;/class&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre> 
       </div> 
      </div>
     </div> <p>Persistence unit in named after the package of the schema-derived classes. If there are several packages, the first one in alphabetic order will be picked up*TODO*. You may also specify the name of the persistence unit expliciltly in <a href="Hyperjaxb3Configuration.html" title="Hyperjaxb3Configuration">configuration</a>.<br> In future versions of Hyperjaxb3 you'll be able to customize this file to include own definitions <b>TODO</b>.</p> <p>You may also turn off the generation of <tt>persistence.xml</tt> <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-CustomizationsHyperjaxb3ReferenceCustomizations"></a><a href="Hyperjaxb3ReferenceCustomizations.html" title="Hyperjaxb3ReferenceCustomizations">Customizations</a></h1> <h4><a name="Hyperjaxb3Reference-NamingHyperjaxb3ReferenceNaming"></a><a href="Hyperjaxb3ReferenceNaming.html" title="Hyperjaxb3ReferenceNaming">Naming</a></h1> <h4><a name="Hyperjaxb3Reference-Annotationsforschemaderivedclasses"></a>Annotations for schema-derived classes</h1> <p>In order to turn schema-derived classes into JPA-compliant <em>entities</em>, Hyperjaxb3 annotates them with an <tt>@Entity</tt> annotation. Entity name is not specified and is implicitly defaulted to the fully qualified name of the derived class.</p> <p>Schema type:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:complexType name="USAddress"&gt;
	&lt;xsd:sequence&gt;
		&lt;!-- ... --&gt;
	&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Derived class:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@Entity
@Table(name = "USAddress")
@Inheritance(strategy = InheritanceType.JOINED)
public class USAddress implements Equals, HashCode
{ ... }</pre> 
       </div> 
      </div>
     </div> <p>You have probably mentioned two further annotations - <tt>@Table</tt> and <tt>@Inheritance</tt>.</p> <h4><a name="Hyperjaxb3Reference-Targetdatabasetable%28%7B%7B@Table%7D%7D%29"></a>Target database table (<tt>@Table</tt>)</h3> <p>The <tt>@Table</tt> annotation provides parameters of the target database table. By default, it only defines the table name which is generated automatically. Table name is typically picked after the class name (corrected, if it's too long or matches a reserved name etc.).</p> <p>Table names and further parameters may be customized using the <tt>hj:table</tt> customization element:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:complexType name="USAddress"&gt;
	&lt;xsd:annotation&gt;
		&lt;xsd:appinfo&gt;
			&lt;hj:table
				 name="address"
				 catalog="..."
				 schema="..."/&gt;
		&lt;/xsd:appinfo&gt;
	&lt;/xsd:annotation&gt;
	&lt;xsd:sequence&gt;
		&lt;!-- ... --&gt;
	&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>In future version you'll be able to declare unique constraints in <tt>hj:table</tt> customizations as well <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Inheritancestrategy%28%7B%7B@Inheritance%7D%7D%29"></a>Inheritance strategy (<tt>@Inheritance</tt>)</h3> <p>JPA is capable of handling hierarchical class structures (inheritance or polyformic mapping). Default inheritance strategy is the single table per class hierarchy. From our experience, schema-derived class hierarchies are better mapped using the <em>joined</em> strategy:</p> <p>A strategy in which fields that are specific to a subclass are mapped to a separate table than the fields that are common to the parent class, and a join is performed to instantiate the subclass.</p> <p>Therefore Hyperjaxb3 per default declares the <tt>@Inheritance(strategy = InheritanceType.JOINED)</tt> annotation. In future releases you'll be able to customize the default inheritance strategy globally for all <b>TODO</b> or locally for some chosen classes <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Markingtransientclasses"></a>Marking transient classes</h3> <p>By default, Hyperjaxb3 makes all of your classes pesistenent. In some cases you may want to exclude some classes to avoid them becoming persistence. For this purpose, attach the <tt>hj:ignored</tt> customization to this class:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="ignoredType"&gt;
	&lt;xs:annotation&gt;
		&lt;xs:appinfo&gt;
			&lt;hj:ignored/&gt;
		&lt;/xs:appinfo&gt;
	&lt;/xs:annotation&gt;
	&lt;!-- ... --&gt;
&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Note that if you mark a type as ignored, all sub-types (those derived by extension or restriction) will be ignored as well. Moreover, all fields of this type (and subtypes) will be made transient.</p> <p>In future versions it will be possible to annotate ignored classes with the <tt>@MappedSuperclass</tt> annotation in order to allow subclasses for being persistent <b>TODO</b>. Another nice-to-have feature is ignoring whole packages <b>TODO</b> and making only certain classes persistent <b>TODO</b> (opposite to making all the classes persistent and ignoring only certain classes).</p> <h4><a name="Hyperjaxb3Reference-Annotationsforproperties"></a>Annotations for properties</h1> <p>The JPA specification does not require persistent properties to be annotated - on the contrary, it's <em>transient</em> properties that must be annotated with the <tt>@Transient</tt> annotation. Nevertheless, Hyperjaxb does annotate all the persistent properties - first, to make it clear what's persistent and, second, avoid ambiguity with implicit annotations.</p> <p>Before we go on discussing property annotations generated by Hyperjaxb3 I first need to describe the taxonomy of property types and cardinalities Hyperjaxb3 needs to handle. This may look a bit complex, but it's essential in order to understand why certain annotation is generated or why Hyperjaxb3 complains it can't handle the situation (and what you can do about this).</p> <h4><a name="Hyperjaxb3Reference-Cardinality"></a>Cardinality</h3> <p>Properties may be <em>single</em> or <em>collections</em>. Single properties contain at most one item and are typically represented in the XML Schema as attributes or elements with <tt>maxOrccurs="1"</tt>. Collection properties may contain several items and are typically represented in the XML Schema as elements with <tt>maxOccurs="n"</tt> where <tt>n&gt;1</tt> or <tt>maxOccurs="unbounded"</tt>. Typically but not always, there are exceptions. On the Java side, in schema-derived classes collection properties have a type of <tt>List&lt;T&gt;</tt>. One JAXB peculiarity is that it generates no setters for collection properties (Hyperjaxb3 has to add <br> setters for these properties).</p> <h4><a name="Hyperjaxb3Reference-Homogeneousandheterogeneousproperties"></a>Homogeneous and heterogeneous properties</h3> <p>Properties usually contain items of a single type only. These properties are called <em>homogeneous</em> since they contain homogeneous content. However, in some cases JAXB generates <em>heterogeneous</em> properties which contain items of different types (for instance, strings and other elements for the mixed content properties). JPA as well as most modern ORM can't handle this case - therefore Hyperjaxb3 needs to "homogenize" heterogeneous properties.</p> <h4><a name="Hyperjaxb3Reference-Propertytypes"></a>Property types</h3> <p>For the usual case of a homogeneous properties, there are several type categories to consider:</p> 
     <ul> 
      <li>Basic properties. Numbers, strings, dates and so on. Most XML Schema's simple types (with the exception of enumerated types.</li> 
      <li>Enumerated properties having Java 5 enums as content. Usually generated from simple types with enumerations.</li> 
      <li>DOM properties - with DOM elements as content. Result from <tt>xsd:any</tt> with <tt>skip</tt> processing or <tt>xjc:dom</tt> customization.</li> 
      <li>Any-type properties - with unmarshalled objects as content. Result from <tt>xsd:any</tt> with <tt>strict</tt> processing or <tt>xsd:anyType</tt> type.</li> 
      <li>Complex properties - contain instances of schema-derived classes.</li> 
      <li>Heterogeneous properties - contain several types of content.</li> 
     </ul> <h4><a name="Hyperjaxb3Reference-Referenceproperties"></a>Reference properties</h3> <p>There is a further peculiarity of JAXB to be taken into an account. In some cases JAXB wraps the content in a <tt>JAXBElement</tt> so you'll get <tt>JAXBElement&lt;T&gt;</tt>-typed property instead of <tt>T</tt>-typed property:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:element
    name="stringNillable"
    type="xsd:string"
    minOccurs="0"
    nillable="true"/&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">public JAXBElement&lt;String&gt; getStringNillable() {
        return stringNillable;
    }</pre> 
       </div> 
      </div>
     </div> <p>This happens not only with nillable elements but also in a number of further scenarios. JPA can't handle JAXBElement so Hyperjaxb3 has to adapt/wrap it as well.</p> <h4><a name="Hyperjaxb3Reference-Transientproperty"></a>Transient property</h2> <p>By default, Hyperjaxb3 will make the property transient (annotate it with <tt>@Transient</tt>) in two cases: if it decides it can't handle this property or if you explicitly customize it to be transient.</p> <p>The first case occurs if Hyperjaxb3 finds out that it can't generate an appropriate mapping or adapting code for the given property. You'll also see a warning and (usually) a reference to the corresponding issue. Theoretically all the JAXB properties are ORM-mappable, so it's just a matter of time for all cases to be implemented.</p> <p>You may also explicitly customize a property to be transient. To do this, simply use the <tt>&lt;hj:ignored/&gt;</tt> customization (just like with classes):</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="ignoredFieldsType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="a" type="xs:string"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:appinfo&gt;
						&lt;hj:ignored/&gt;
					&lt;/xs:appinfo&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;!-- ... --&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Note that this will make property transient in the given schema-derived class as well as in all its subclasses.</p> <h4><a name="Hyperjaxb3Reference-Identifierproperty"></a>Identifier property</h2> <p>According to the EJB3 spec, every entity must have a primary key. The primary key must be defined on the entity that is the root of the entity hierarchy or on a mapped<br> superclass of the entity hierarchy. The primary key must be defined exactly once in an entity hierarchy. This basically means that root schema-derived classes (those having no schema-derived superclass) must declare and identifier property. There is two ways to do this: either let Hyperjaxb3 generate a default identifier property for you or mark an existing property as identifier using a customization.</p> <h4><a name="Hyperjaxb3Reference-Generatingdefaultidentifier"></a>Generating default identifier</h3> <p>If you do not customize some property to be an identifier, Hyperjaxb3 will generate a default identifier property for you:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAttribute
    protected Long hjid;

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "Hjid")
    public Long getHjid() {
        return hjid;
    }

    public void setHjid(Long value) {
        this.hjid = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>Default identifier property is called <tt>hjid</tt> and has the <tt>java.lang.Long</tt> type. It gets a generated value produced by the automatic strategy. Hyperjaxb3 also makes this property an attribute of the schema-derived class (so you'll see <tt>hjid="1234"</tt> when you marshal your object. In future releases you'll be able to customize the name, type and further attributes of the default identifier property <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Usinganexistingpropertyasidentifier"></a>Using an existing property as identifier</h3> <p>Alternatively, you may mark an existing property as identifier. Simply mark it with the <tt>&lt;hj:id/&gt;</tt> customization - and Hyperjaxb3 will use it as an identifier instead of generating a new property.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="customizedIdType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="id" type="xs:long"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:appinfo&gt;
						&lt;hj:id/&gt;
					&lt;/xs:appinfo&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;!-- ... --&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">protected long id;

    @Id
    @Column(name = "Id")
    public long getId() {
        return id;
    }

    public void setId(long value) {
        this.id = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>Please note that your identifier property must have an appropriate type (spec allows any Java primitive type, any primitive wrapper type, <tt>java.lang.String</tt>, <tt>java.util.Date</tt>, <tt>java.sql.Date</tt> however floating-point types are not recommended).</p> <h4><a name="Hyperjaxb3Reference-Customizingtheidentifierproperty"></a>Customizing the identifier property</h3> <p>The <tt>hj:id</tt> customization element may contain the <tt>hj:column</tt> (<a href="https://hyperjaxb3.java.net/issues/show_bug.cgi-134">issue 134</a>), <tt>hj:generated-value</tt>, <tt>hj:temporal</tt> (<a href="https://hyperjaxb3.java.net/issues/show_bug.cgi-135">issue 135</a>), <tt>hj:table-generator</tt> and <tt>hj:sequence-generator</tt> customizations. Below is a typical usage example:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:attribute name="id" use="optional" type="xsd:int"&gt;
	&lt;xsd:annotation&gt;
		&lt;xsd:appinfo&gt;
			&lt;hj:id&gt;
				&lt;hj:generated-value strategy="SEQUENCE" generator="mySequenceGenerator"/&gt;
				&lt;hj:sequence-generator
					name="mySequenceGenerator"
					sequence-name="mySequence"
					initial-value="1"
					allocation-size="100"/&gt;
			&lt;/hj:id&gt;
		&lt;/xsd:appinfo&gt;
	&lt;/xsd:annotation&gt;
&lt;/xsd:attribute&gt;</pre> 
       </div> 
      </div>
     </div> <h4><a name="Hyperjaxb3Reference-Versionproperty"></a>Version property</h2> <p>In case you want to allow for performing optimistic locking with you schema-derived classes, you'll need to have a <em>version</em> property in your entities. Hyperjaxb3 supports this by allowing you to mark an existing property as version using the <tt>&lt;hj:version/&gt;</tt> customization:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="customizedVersionType"&gt;
		&lt;xs:sequence&gt;
			&lt;!-- ... --&gt;
			&lt;xs:element name="version" type="xs:long"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:appinfo&gt;
						&lt;hj:version/&gt;
					&lt;/xs:appinfo&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">protected long version;

    @Version
    @Column(name = "Version")
    public long getVersion() {
        return version;
    }

    public void setVersion(long value) {
        this.version = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>Note that version properties have also type constraints (<tt>int</tt>, <tt>java.lang.Integer</tt>, <tt>short</tt>, <tt>java.lang.Short</tt>, <tt>long</tt>, <tt>java.lang.Long</tt>, <tt>java.sql.Timestamp</tt>).</p> <h4><a name="Hyperjaxb3Reference-Singlebasicproperty"></a>Single basic property</h2> <p>The simplest case of a persistent property is a single-valued property containing a simple value. This type of properties is annotated with the <tt>@Basic</tt> annotation:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:element name="string" type="xs:string" minOccurs="0"/&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">protected String string;

    @Basic
    @Column(name = "String")
    public String getString() {
        return string;
    }

    public void setString(String value) {
        this.string = value;
    }</pre> 
       </div> 
      </div>
     </div> <h4><a name="Hyperjaxb3Reference-Consideringfacets"></a>Considering facets</h3> <p>Since 0.3.</p> <p>In case your simple type of your property contains constraining faces like <tt>minLength</tt>, <tt>maxLength</tt>, <tt>length</tt>, <tt>totalDigits</tt>, <tt>fractionDigits</tt>, Hyperjaxb3 will consider them when generating the <tt>@Column</tt> annotation. Hyperjaxb3 considers not only the type itself, but its parent types as well.</p> <p>If <tt>length</tt> or <tt>maxLength</tt> are defined, they are used as the <tt>length</tt> attribute of <tt>@Column</tt> (<tt>length</tt> has priority over <tt>maxLength</tt>). If <tt>minLength</tt> is defined and it's greater that <tt>127</tt> the <tt>minLength * 2</tt> is used as <tt>length</tt> of the <tt>@Column</tt>.</p> <p>If <tt>totalDigits</tt> facet is defined, its value is used as the <tt>precision</tt> attribute of the <tt>@Column</tt>. If <tt>fractionDigits</tt> facet is found, its value is used as the <tt>scale</tt> attribute of the <tt>@Column</tt>.</p> <p>Check the following example:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:simpleType name="largeMinLength"&gt;
		&lt;xsd:restriction base="xsd:string"&gt;
			&lt;xsd:minLength value="200"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;


	&lt;xsd:simpleType name="minLength"&gt;
		&lt;xsd:restriction base="xsd:string"&gt;
			&lt;xsd:minLength value="5"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;

	&lt;xsd:simpleType name="maxLength"&gt;
		&lt;xsd:restriction base="test:minLength"&gt;
			&lt;xsd:maxLength value="10"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;

	&lt;xsd:simpleType name="length"&gt;
		&lt;xsd:restriction base="test:maxLength"&gt;
			&lt;xsd:length value="8"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;

	&lt;xsd:simpleType name="digits"&gt;
		&lt;xsd:restriction base="xsd:decimal"&gt;
			&lt;xsd:totalDigits value="5"/&gt;
			&lt;xsd:fractionDigits value="2"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;

	&lt;xsd:simpleType name="totalDigits"&gt;
		&lt;xsd:restriction base="xsd:decimal"&gt;
			&lt;xsd:totalDigits value="3"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;

	&lt;xsd:simpleType name="fractionDigits"&gt;
		&lt;xsd:restriction base="xsd:decimal"&gt;
			&lt;xsd:fractionDigits value="2"/&gt;
		&lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Produces the following:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@Basic
    @Column(name = "LARGEMINLENGTH", length = 400)
    public String getLargeMinLength() { ... }

    @Basic
    @Column(name = "MINLENGTH")
    public String getMinLength() { ... }

    @Basic
    @Column(name = "MAXLENGTH", length = 10)
    public String getMaxLength() { ... }

    @Basic
    @Column(name = "LENGTH_", length = 8)
    public String getLength() { ... }

    @Basic
    @Column(name = "DIGITS", precision = 5, scale = 2)
    public BigDecimal getDigits() { ... }

    @Basic
    @Column(name = "TOTALDIGITS", precision = 3)
    public BigDecimal getTotalDigits() { ... }

    @Basic
    @Column(name = "FRACTIONDIGITS", scale = 2)
    public BigDecimal getFractionDigits() { ... }</pre> 
       </div> 
      </div>
     </div> <h4><a name="Hyperjaxb3Reference-Adaptedproperty"></a>Adapted property</h3> <p>Due to JPA limitations, in some cases even common simple types are cannot be mapped. There's also no mechanism to define an implicit conversion. Hyperjaxb3 handles this type of properties by <em>adapting</em> them with an explicit conversion.</p> <p>Consider the following example of a <tt>xs:QName</tt>-typed element:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:element name="QName" type="xs:QName" minOccurs="0"/&gt;</pre> 
       </div> 
      </div>
     </div> <p>JAXB generates a <tt>javax.xml.namespace.QName</tt>-typed property which is not supported by JPA:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElement(name = "QName")
    protected QName qName;

    public QName getQName() {
        return qName;
    }

    public void setQName(QName value) {
        this.qName = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>To handle this case, JAXB makes the <tt>QName</tt> property itself transient and generates an additional <tt>QNameItem</tt> property which performs an on-the-fly conversion of <tt>QName</tt>:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElement(name = "QName")
    protected QName qName;

    @Transient
    public QName getQName() {
        return qName;
    }

    public void setQName(QName value) {
        this.qName = value;
    }

    @Basic
    @Column(name = "QNameItem")
    public String getQNameItem() {
        return XmlAdapterUtils.unmarshall(QNameAsString.class, this.qName);
    }

    public void setQNameItem(String target) {
        this.qName = XmlAdapterUtils.marshall(QNameAsString.class, target);
    }</pre> 
       </div> 
      </div>
     </div> <p>The <tt>QNameItem</tt> property added by Hyperjaxb3 uses the <tt>QNameAsString</tt> built-in adapter which converts <tt>QName</tt> to string and back. Thus the <tt>QName</tt> will be persisted in the database as string. The conversion is done implicitly in the additional <tt>QNameItem</tt> property, all the other APIs are left intact.</p> <p>In future releases you'll be able to customize the name of the adapting property as well as the used adapter class <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Temporalproperties"></a>Temporal properties</h3> <p>JPA requires temporal properties like date, time and so on to be annotated with the <tt>@Temporal</tt> annotations.<br> Hyperjaxb3 detects temporal properties and chooses the appropriate temporal type <tt>TemporalType.DATE</tt>, <tt>TemporalType.TIME</tt> or <tt>TemporalType.TIMESTAMP</tt>. Temporal type is chosen based on the Java type of the property and its type in the XML Schema:</p> 
     <ul> 
      <li><tt>java.sql.Date</tt> maps to <tt>TemporalType.DATE</tt>.</li> 
      <li><tt>java.sql.Time</tt> maps to <tt>TemporalType.TIME</tt>.</li> 
      <li><tt>java.sql.Timestamp</tt> maps to <tt>TemporalType.TIMESTAMP</tt>.</li> 
      <li><tt>java.util.Calendar</tt> maps to <tt>TemporalType.TIMESTAMP</tt>.</li> 
      <li><tt>xsd:date</tt>, <tt>xsd:gYearMonth</tt>, <tt>xsd:gYear</tt>, <tt>xsd:gMonth</tt>, <tt>xsd:gMonthDay</tt>, <tt>xsd:gDay</tt> maps to <tt>TemporalType.DATE</tt>.</li> 
      <li><tt>xsd:time</tt> maps to <tt>TemporalType.TIME</tt>.</li> 
      <li><tt>xsd:dateTime</tt> maps to <tt>TemporalType.TIMESTAMP</tt>.</li> 
      <li>All other cases map to <tt>TemporalType.TIMESTAMP</tt> (fallback behaviour).</li> 
     </ul> <p>In future releases you'll be able to customize the generated <tt>@Temporal</tt> annotation <a href="https://hyperjaxb3.java.net/issues/show_bug.cgi-136">issue 136</a>.</p> <h4><a name="Hyperjaxb3Reference-Singleenumeratedproperty"></a>Single enumerated property</h2> <p>In case you have an enumerated simple type in your schema, JAXB can produce a Java 5 <tt>enum</tt> for this type. COnsider the following enumerated simple type:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:simpleType name="SexType"&gt;
	&lt;xsd:restriction base="xsd:string"&gt;
		&lt;xsd:enumeration value="Male"/&gt;
		&lt;xsd:enumeration value="Female"/&gt;
	&lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;</pre> 
       </div> 
      </div>
     </div> <p>JAXB produces a corresponding <tt>SexType</tt> enum with <tt>MALE</tt> and <tt>FEMALE</tt> items (having literal values of <tt>"Male"</tt> and <tt>"Female"</tt> correspondingly.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlType(name = "SexType")
@XmlEnum
public enum SexType {

    @XmlEnumValue("Male")
    MALE("Male"),
    @XmlEnumValue("Female")
    FEMALE("Female");
    private final String value;

    SexType(String v) { value = v; }

    public String value() { return value; }

    public static SexType fromValue(String v) {
        for (SexType c: SexType.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }
}</pre> 
       </div> 
      </div>
     </div> <p>Hyperjaxb3 can detect enum properties produced by JAXB and annotate these properties with <tt>@Enumerated</tt> annotation.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:element name="sex" type="test:SexType"/&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElement(required = true)
    protected SexType sex;

    @Enumerated(EnumType.STRING)
    public SexType getSex() {
        return sex;
    }

    public void setSex(SexType value) {
        this.sex = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>By default, Hyperjaxb3 uses string representation of the enum, <tt>EnumType.STRING</tt>. Another option would be <tt>EnumType.ORDINAL</tt>. In future releases you could configure the default value <b>TODO</b> or customize specific properties <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-SingleDOMproperty"></a>Single DOM property</h2> <p>In certain scenarios you may want to load parts of XML into you object structure without unmarshalling. This may be some semi-structured markup which does not fit object structures well - or simply arbitrary <tt>xsd:any</tt> content. To resolve this, JAXB allows unmarshalling parts of XML as DOM element.</p> <p>There are two main methods to get DOM elements into you objects:</p> 
     <ul> 
      <li>using the <tt>xjc:dom</tt> customization;</li> 
      <li>using <tt>xsd:any</tt> with <tt>processContents="skip"</tt>.</li> 
     </ul> <p>In both cases you'll get an DOM element-typed property (<tt>org.w3c.dom.Element</tt> as type by default).</p> <p>Element customized with <tt>xjc:dom</tt>:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:element name="content" minOccurs="0"&gt;
	&lt;xsd:annotation&gt;
		&lt;xsd:appinfo&gt;
			&lt;xjc:dom/&gt;
		&lt;/xsd:appinfo&gt;
	&lt;/xsd:annotation&gt;
&lt;/xsd:element&gt;</pre> 
       </div> 
      </div>
     </div> <p>Turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement
    protected Element content;

    public Element getContent() {
        return content;
    }

    public void setContent(Element value) {
        this.content = value;
    }</pre> 
       </div> 
      </div>
     </div> <p><tt>xsd:any</tt> with <tt>processContents="skip"</tt>:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:any namespace="##other" processContents="skip" minOccurs="0" axOccurs="1"/&gt;</pre> 
       </div> 
      </div>
     </div> <p>turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement
    protected Element any;

    public Element getAny() {
        return any;
    }

    public void setAny(Element value) {
        this.any = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>Note that there are some JAXB limitation on DOM contents.</p> <p>As you see, Java representation is in both cases identical. The problem between JAXB and JPA is that JPA can't persist DOM elements. Therefor Hyperjaxb3 needs to generate a wrapping property which serializes DOM into string in getter and parses the string back to DOM in setter:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement
    protected Element any;

    @Transient
    public Element getAny() {
        return any;
    }

    public void setAny(Element value) {
        this.any = value;
    }

    @Basic
    @Column(name = "AnyItem")
    public String getAnyItem() {
        return XmlAdapterUtils.unmarshall(ElementAsString.class, this.any);
    }

    public void setAnyItem(String target) {

        this.any = XmlAdapterUtils.marshall(ElementAsString.class, target);
    }</pre> 
       </div> 
      </div>
     </div> <p>The original property is made transient, while the wrapping property (which is string-typed) is annotated as <tt>@Basic</tt>. In future releases you'll be able to customize the name of the wrapping property <b>TODO</b> and override the default <tt>ElementAsString</tt> adapter <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Singleanytypeproperty"></a>Single any-type property</h2> <p>A further JAXB feature is generic or any-type properties like those generated from <tt>xsd:anyType</tt>-typed elements or <tt>xsd:any</tt> with strict processing:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="1"/&gt;</pre> 
       </div> 
      </div>
     </div> <p>Turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement(lax = true)
    protected Object any;

    public Object getAny() {
        return any;
    }

    public void setAny(Object value) {
        this.any = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>JPA can't handle these generic properties. Hyperjaxb3's approach to handle this scenario is to adapt the property by marshalling its contents into string in getter and unmarshalling the string in setter. By default, Hyperjaxb3 uses the context path of the currently processed schema (or schemas). In future releases you'll be able to customize this <b>TODO</b>. You'll be able to customize the name of the adapting property as well.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement(lax = true)
    protected Object any;

    @Transient
    public Object getAny() {
        return any;
    }

    public void setAny(Object value) {
        this.any = value;
    }


    @Basic
    @Column(name = "AnyItem")
    public String getAnyItem() {
        return JAXBContextUtils.unmarshall("org.jvnet.hyperjaxb3.ejb.tests.any", this.any);
    }

    public void setAnyItem(String target) {
        this.any = JAXBContextUtils.marshall("org.jvnet.hyperjaxb3.ejb.tests.any", target);
    }</pre> 
       </div> 
      </div>
     </div> <p>The approach presented above is quite similar to how the DOM elements are processed. The only difference is that instead of using XML parsing and serialization, contents of the property are marshalled/unmarshalled with JAXB context.</p> <h4><a name="Hyperjaxb3Reference-Singlecomplexproperty"></a>Single complex property</h2> <p>If you have an complex-type element, this will be probably represented on the Java side as complex property - a property which has a schema-derived class as its type:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="complexTypesType"&gt;
	&lt;xs:sequence&gt;
			&lt;xs:element name="single" type="complexType" minOccurs="0"/&gt;
			&lt;!-- ... --&gt;
	&lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
&lt;xs:complexType name="complexType"&gt;
	&lt;xs:sequence&gt;
		&lt;xs:element name="a" type="xs:string" minOccurs="0"/&gt;
		&lt;xs:element name="b" type="xs:long" minOccurs="0"/&gt;
	&lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">protected ComplexType single;

    public ComplexType getSingle() {
        return single;
    }

    public void setSingle(ComplexType value) {
        this.single = value;
    }</pre> 
       </div> 
      </div>
     </div> <p>Hyperjaxb3 annotates complex single properties with <tt>@ManyToOne</tt> annotation:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@ManyToOne(cascade = {
        CascadeType.ALL
    })
    public ComplexType getSingle() {
        return single;
    }</pre> 
       </div> 
      </div>
     </div> <p>Since the type of the property is known from the return type of the method, the <tt>targetEntity</tt> attribute of the annotation is not necessary.<br> By default, Hyperjaxb3 adds {{cascade=</p> 
     <div class="error">
      <span class="error">Unknown macro: {CascadeType.ALL}</span> 
     </div> <p>}} meaning that all the persistent actions (persist, merge, remove, refresh) will be cascaded. In future releases you'll be able to customize the <tt>cascade</tt> <b>TODO</b> as well as <tt>fetch</tt> <b>TODO</b> and <tt>optional</tt> <b>TODO</b> attributes.</p> <p>Two further persistence options for complex single properties are <tt>@OneToOne</tt> <b>TODO</b> and <tt>@Embedded</tt>/<tt>@Embeddable</tt> <b>TODO</b>. They will be implemented in future versions.</p> <h4><a name="Hyperjaxb3Reference-Singleheterogeneousproperty"></a>Single heterogeneous property</h2> <p>In some cases your single-valued property may be multi-typed. For instance, if you have <tt>xsd:any</tt> content with <tt>processContents="lax"</tt>, this results a property which would contain either <tt>JAXBElement</tt> representing unmarshalled content or <tt>org.w3c.dom.Element</tt> holding a DOM representation of XML if unmarshalling did not succeeded:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:any namespace="##other" processContents="lax"
	minOccurs="0" maxOccurs="1"/&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAnyElement(lax = true)
        protected Object any;

        /**
         * Gets the value of the any property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     {@link Element }
         *     
         */
        public Object getAny() {
            return any;
        }

        /**
         * Sets the value of the any property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     {@link Element }
         *     
         */
        public void setAny(Object value) {
            this.any = value;
        }</pre> 
       </div> 
      </div>
     </div> <p>This case is currently not fully implemented (see <a href="https://hyperjaxb3.java.net/issues/show_bug.cgi-44">issue 44</a>). Currently Hyperjaxb3 only supports the particular case shown above <b>TBD</b>.</p> <h4><a name="Hyperjaxb3Reference-Elementreferencingproperties"></a>Element-referencing properties</h2> <p>Under some circumstances you'll be getting instead of getting a normally typed property you'll be getting <tt>JAXBElement&lt;T&gt;</tt>-typed property. A typical case are elements marked with <tt>nillable="true"</tt>.</p> <p>A small note on <tt>minOccurs="0"</tt> and <tt>nillable="true"</tt>. They mean two different things. For a truly optional element, one that is allowed to be absent altogether, minOccurs="0" is what you want. <tt>nillable="true"</tt> means that the element can be present without its normal content, provided that <tt>xsi:nil="true"</tt> is one of its attributes.</p> <p>Consider the following example:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:element name="longNillable" type="xs:long"
	minOccurs="0" nillable="true"/&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElementRef(name = "longNillable", type = JAXBElement.class)
    protected JAXBElement&lt;Long&gt; longNillable;

    public JAXBElement&lt;Long&gt; getLongNillable() {
        return longNillable;
    }

    public void setLongNillable(JAXBElement&lt;Long&gt; value) {
        this.longNillable = ((JAXBElement&lt;Long&gt; ) value);
    }</pre> 
       </div> 
      </div>
     </div> <p>In this case JAXB uses the <tt>JAXBElement</tt> to realize the "nillability" semantics for single properties. There are further cases where you get <tt>JAXBElement&lt;T&gt;</tt> instead of simply <tt>T</tt> as type. And, as already mentioned before, JPA can't handle this type of properties.</p> <p>Hyperjaxb3 tries to handle this situation by adding an adapting property:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElementRef(name = "longNillable", type = JAXBElement.class)
    protected JAXBElement&lt;Long&gt; longNillable;

    @Transient
    public JAXBElement&lt;Long&gt; getLongNillable() {
        return longNillable;
    }

    public void setLongNillable(JAXBElement&lt;Long&gt; value) {
        this.longNillable = ((JAXBElement&lt;Long&gt;) value);
    }

    // ...

    @Basic
    @Column(name = "LongNillableItem")
    public Long getLongNillableItem() {
        return XmlAdapterUtils.unmarshallJAXBElement(this.longNillable);
    }

    public void setLongNillableItem(Long target) {
        this.longNillable = XmlAdapterUtils.marshallJAXBElement(Long.class, new QName("", "longNillable"), SimpleTypesType.class, target);
    }</pre> 
       </div> 
      </div>
     </div> <p>In the example above, Hyperjaxb3 has added the <tt>longNillableItem</tt> property (property name will be customizable in future <b>TODO</b>). Since there is only one possible element for this property, it can be embedded into marshalling/unmarshalling. Unfortunatelly, <tt>nil</tt> semantics are lost in this case. Moreover, this approach does not work if a property may reference several elements (like with substitution groups). I'll try to find a better solution in future versions <b>TODO</b>. Probably an <tt>@Embeddable</tt> item.</p> <h4><a name="Hyperjaxb3Reference-Complexcollectionproperty"></a>Complex collection property</h2> <p>Repeatable complex type elements are turned into complex collections:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="complexTypesType"&gt;
	&lt;xs:sequence&gt;
		&lt;xs:element name="collection" type="complexType" minOccurs="0" maxOccurs="unbounded"/&gt;
	&lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">protected List&lt;ComplexType&gt; collection;

    @OneToMany(cascade = {
        CascadeType.ALL
    })
    @JoinTable(name = "COMPLEXTYPESTYPE_COLLECTION")
    public List&lt;ComplexType&gt; getCollection() {
        if (collection == null) {
            collection = new ArrayList&lt;ComplexType&gt;();
        }
        return this.collection;
    }

    public void setCollection(List&lt;ComplexType&gt; collection) {
        this.collection = collection;
    }</pre> 
       </div> 
      </div>
     </div> <p>Hyperjaxb3 uses <tt>@OneToMany</tt> to annotate this type of properties. By default, all actions are cascaded (<b>TODO</b> allow for customization). The joining table name is generated automatically (<b>TODO</b> allow for customization). Future versions will provide extensive customization possibilities (like using <tt>@ManyToMany</tt>, customizing annotation parameters and so on) <b>TODO</b>.</p> <h4><a name="Hyperjaxb3Reference-Collectionbasic%2Cenumerated%2CDOMoranytypeproperty"></a>Collection basic, enumerated, DOM or any-type property</h2> <p>Previous section discussed single-valued properties which typically result from attributes and elements with <tt>maxOccurs="1"</tt> (or with <tt>maxOccurs</tt> omitted, which is the same). If you have a greater <tt>maxOccurs</tt> specified, your property will be probably a collection.</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:element name="int" type="xs:int"
	minOccurs="0" maxOccurs="unbounded"/&gt;</pre> 
       </div> 
      </div>
     </div> <p>Turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElement(name = "int", type = Integer.class)
    protected List&lt;Integer&gt; _int;

    public List&lt;Integer&gt; getInt() {
        if (_int == null) {
            _int = new ArrayList&lt;Integer&gt;();
        }
        return this._int;
    }</pre> 
       </div> 
      </div>
     </div> <p>As I mentioned before, the first problem between JPA and JAXB that concerns collections is that JAXB does not generate setters for collection properties. JAXB assumes you can do <tt>getMyCollectionProperty().add(myNewValue)</tt>. However, JPA requires setters for all the properties. Therefore Hyperjaxb3 adds the missing setters:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">public void setInt(List&lt;Integer&gt; _int) {
        this._int = _int;
    }</pre> 
       </div> 
      </div>
     </div> <p>The second (and much more severe) problem is JPA limitation that it can't handle collections of simple types. Only collections of entities are allowed. I've heard that this may be changed in the future version of JPA spec, but right now Hyperjaxb3 need to create an artificial entity class in order to make simple collections persistable.</p> <p>Here's how it works. Hyperjaxb3 creates a new <tt>MyPropertyItem</tt> entity class. This class just holds an id and a single <tt>item</tt> field corresponding to the item of the single collection:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlAccessorType(XmlAccessType.FIELD)
    @Entity(name = "org.jvnet.hyperjaxb3.ejb.tests.one.SimpleCollectionTypesType$IntItem")
    @Table(name = "SCTTINTITEM")
    @Inheritance(strategy = InheritanceType.JOINED)
    public static class IntItem
        implements Item&lt;Integer&gt;
    {

        @XmlElement(name = "int")
        protected Integer item;
        @XmlAttribute
        protected Long hjid;

        @Basic
        @Column(name = "ITEM")
        public Integer getItem() {
            return item;
        }

        public void setItem(Integer value) {
            this.item = value;
        }

        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name = "HJID")
        public Long getHjid() {
            return hjid;
        }

        public void setHjid(Long value) {
            this.hjid = value;
        }
    }</pre> 
       </div> 
      </div>
     </div> <p>This entity class is intended to wrap item of the collection. Next step is to adapt our simple-typed collection so that it becomes a collection of wrapping entities:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@OneToMany(cascade = {
        CascadeType.ALL
    })
    @JoinTable(name = "SCTT_INTITEM")
    public List&lt;SimpleCollectionTypesType.IntItem&gt; getIntItems() {
        if (this.intItems == null) {
            this.intItems = new ArrayList&lt;SimpleCollectionTypesType.IntItem&gt;();
        }
        if (ItemUtils.shouldBeWrapped(this._int)) {
            this._int = ItemUtils.wrap(this._int, this.intItems, SimpleCollectionTypesType.IntItem.class);
        }
        return this.intItems;
    }

    public void setIntItems(List&lt;SimpleCollectionTypesType.IntItem&gt; value) {
        this._int = null;
        this.intItems = null;
        this.intItems = value;
        if (this.intItems == null) {
            this.intItems = new ArrayList&lt;SimpleCollectionTypesType.IntItem&gt;();
        }
        if (ItemUtils.shouldBeWrapped(this._int)) {
            this._int = ItemUtils.wrap(this._int, this.intItems, SimpleCollectionTypesType.IntItem.class);
        }
    }

    @Transient
    public List&lt;Integer&gt; getInt() {
        if (_int == null) {
            _int = new ArrayList&lt;Integer&gt;();
        }
        return this._int;
    }

    public void setInt(List&lt;Integer&gt; _int) {
        this._int = _int;
    }</pre> 
       </div> 
      </div>
     </div> <p>This approach is applied to all the collection properties with the exception of complex and heterogeneous collections. I personally don't think that this solution is that perfect - but it works and currently I don't have other options.</p> <h4><a name="Hyperjaxb3Reference-Heterogeneouscollectionproperty"></a>Heterogeneous collection property</h2> <p>In some cases JAXB generates multi-typed or heterogeneous properties. Here's an example:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">&lt;xs:complexType name="heteroSequenceType"&gt;
	&lt;xs:sequence&gt;
		&lt;!-- ... --&gt;
		&lt;xs:sequence maxOccurs="unbounded"&gt;
			&lt;xs:element name="k" type="xs:string" nillable="true"/&gt;
			&lt;xs:element name="l" type="complexType" nillable="true"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</pre> 
       </div> 
      </div>
     </div> <p>Turns into:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">@XmlElements({
        @XmlElement(name = "l", required = true, type = ComplexType.class, nillable = true),
        @XmlElement(name = "k", required = true, type = String.class, nillable = true)
    })
    protected List&lt;Object&gt; kAndL;


    /**
     * ...
     * Objects of the following type(s) are allowed in the list
     * {@link ComplexType }
     * {@link String }
     */
    @Transient
    public List&lt;Object&gt; getKAndL() {
        if (kAndL == null) {
            kAndL = new ArrayList&lt;Object&gt;();
        }
        return this.kAndL;
    }

    public void setKAndL(List&lt;Object&gt; kAndL) {
        this.kAndL = kAndL;
    }</pre> 
       </div> 
      </div>
     </div> <p>These types require homogenization. This type of properties are currently not supported (see <a href="https://hyperjaxb3.java.net/issues/show_bug.cgi-53">issue 53</a>).</p> <h4><a name="Hyperjaxb3Reference-Addingcustomannotationstogeneratedbindings"></a>Adding custom annotations to generated bindings</h2> <p>Details TBD. For now see example in <a href="https://hj3.java.net/svn/hj3/trunk/ejb/tests/annox">ejb/tests/annox</a></p> 
     <hr> </td> 
   </tr> 
  </tbody>
 </table>    
</body></div>
        <br/>

        <!-- footer================================================== -->
        <footer class="well">
            <div class="container">

                <div class="row-fluid" id="bottom-info">
                    <!--div class="span6 pagination-centered" id="social"-->
                    <div class="span4" id="social">			
                        <a href="http://blogs.oracle.com/theaquarium/"><img src="../images/icons/TheAquarium.png"></a>
                        <a href="https://twitter.com/glassfish"><img src="../images/icons/twitter.png"></a>
                        <a href="https://plus.google.com/communities/106098646151660933759"><img src="../images/icons/google.png"></a>
                        <a href="http://www.linkedin.com/groups/GlassFish-Users-106819/about"><img src="../images/icons/linkedin.png"></a>
                        <a href="http://www.youtube.com/user/GlassFishVideos"><img src="../images/icons/youtube.png"></a>
                        <a href="https://www.facebook.com/GlassFish"><img src="../images/icons/facebook.png"></a>
                    </div>

                    <div class="span8" id="copyright">Page last changed on Jul 12, 2010 by 
<font color="#0050B2">am74686</font>. Exported from wikis.oracle.com on May 27, 2015 20:49.<br/>
                        Copyright &copy; 2005-2015 Oracle Corporation and/or its affiliates.</div>
                </div>
            </div>
        </footer>

        <!-- ================================================== -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/bootstrap-tab.js"></script>
	<script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<!--  Begin SiteCatalyst code  -->
  	<!--  End SiteCatalyst code  -->
    </body>
</html>