<!DOCTYPE html>
<html  xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>GlassFish Wiki : Gfv3AppclientcontainerDesign</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="" />
        <meta http-equiv="content-language" content="en" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap.min.css" rel="stylesheet" />
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
        <link href="styles/docs.css" rel="stylesheet" />
        <link href="styles/site1.css" rel="stylesheet" />
        <style> a { color: #555555; } </style>
        <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body class="page-documentation project-gfmvnsite" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

        <div class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <div class="brand"><a href="/glassfish/index.html"><img src="../images/gflogo24.png"><span style="color:#E88A43;font-size:18px;padding-left:11px;padding-top:15px;font-weight:bold;">GlassFish</span> - <span style="font-size:18px;" class="gf-grey">World's first Java EE 7 Application Server</span></a></div>
                    <div class="nav-collapse">
                        <ul class="nav pull-right">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                                <ul class="dropdown-menu">
									<li><a href="/glassfish/LICENSE" title="License">Legal </a></li>
									<li><a href="/glassfish/CONTRIBUTING" title="Contributing">Contributing </a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><!--/.nav-collapse -->
                </div>
            </div>
        </div>

        <br/><br/>
        <div class="container"><body> 
 <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff"> 
  <tbody>
   <tr> 
    <td valign="top" class="pagebody">   <h4><a name="Gfv3AppclientcontainerDesign-AppClientContainerDesignNotes"></a>App Client Container Design Notes</h1> <p>[</p> 
     <div class="error">
      <span class="error">Unknown macro: {TableOfContents title='App Client Container Design'}</span> 
     </div> <p>|(TableOfContentstitle='AppClientContainerDesign')]</p> 
     <div class="panel" style="border-width: 1px;">
      <div class="panelContent"> 
       <p><b>NOTE: This document continues to evolve.</b></p> 
       <hr> 
       <p>Jspwiki style: center</p> 
      </div>
     </div> <h4><a name="Gfv3AppclientcontainerDesign-1.Introduction"></a>1. Introduction</h1> <p>Date of This Document:<br> initial 6 Mar 2009</p> <h4><a name="Gfv3AppclientcontainerDesign-1.1Moduleandsubmodulestructure"></a>1.1 Module and submodule structure</h2> 
     <ul> 
      <li>appclient/ - new top-level module 
       <ul> 
        <li>server/ 
         <ul> 
          <li>connecto/r - contains only the AppClientSniffer</li> 
          <li>core/ - contains AppClientDeployer and other related classes</li> 
          <li>jws/ - contains server-side classes related to Java Web Start support</li> 
         </ul> </li> 
        <li>client/ 
         <ul> 
          <li>acc/ - builds the OSGi client-side module for app client support</li> 
          <li>acc-config/ - classes generated by JAXB for the sun-acc.xml format - also used by appclient.security module</li> 
          <li>acc-scripts/ - the Windows and non-Windows appclient scripts</li> 
          <li>acc-standalone/ - builds a static non-OSGi JAR for non-OSGi launches</li> 
          <li>jws/ - builds a JAR containing the client-side classes and resources used only during Java Web Start launches</li> 
         </ul> </li> 
       </ul> </li> 
     </ul> <p>Notes</p> <p>Currently the jws modules are empty. That support will come after MS1. To minimize the number of module JARs the server must load, we might merge the content of the server-side jws module into the core module. </p> <p>I have talked to Jerome about generalizing the current app server bootstrapping classes (ASMain, AbstractMain, etc.) so they would meet the ACC's needs also. I have looked into this and decided that we should revisit this post MS1.</p> <p>Ideally the appclient/client/acc module would build both the OSGi JAR and the static JAR, the two sharing the same dependencies but just recording them differently in their manifests. It might be possible to do this by using the default config and execution for the hk2-jar plug-in and specifying a non-default config and execution for the jar plug-in to create the static JAR. We will need to avoid placing copies of the same resources and classes into the two JARs which we can do using "exclude." Short-term it was simpler to create the acc-standalone submodule which depends on acc.</p> <p>The current plug-in implementations (jar and hk2-jar) seem to create the Class-Path we need in the static JAR from the dependencies we declare. But there are some additional JARs that are not OSGi JARs that we need to add to the class path. To handle this the appclient/client/acc-standalone module adds to the automatically-generated class path.</p> <h4><a name="Gfv3AppclientcontainerDesign-1.2OverviewofDeployment%2CDownload%2CandLaunch"></a>1.2 Overview of Deployment, Download, and Launch</h2> <h4><a name="Gfv3AppclientcontainerDesign-1.2.1Reviewofv2"></a>1.2.1 Review of v2</h3> <p>During deployment of an EAR, v2 expands the EAR into a directory under the applications/javaee tree within the domain's directory. It then expands each submodule JAR from the EAR into its own subdirectory before deleting the submodule JARs.</p> <p>If the EAR contains at least one app client v2 generates an umbrella JAR containing</p> 
     <ul> 
      <li>each app client submodule JAR (reconstituted because the original was deleted, possibly with stub classes added if the users requested that)</li> 
      <li>any JARs declared in the app client JARs' Class-Paths</li> 
      <li>any JARs from the EAR's library directory</li> 
      <li>all JARs at the top-level of the EAR</li> 
      <li>any EJB submodule JARs</li> 
     </ul> <p>This generated JAR is what "deploy --retrieve" and "get-client-stubs" download and what the user launches using the appclient script or Java Web Start. During either type of app client launch the ACC expands this JAR into a temp directory, then constructs and uses a class path that refers to the JARs in the temp directory tree. Users can copy this single JAR to other locations and launch it from there.</p> <p>Problems/Issues</p> 
     <ul> 
      <li>Each launch of the same client re-expands the generated umbrella JAR.</li> 
      <li>If the developer signed any of the submodule JARs v2 loses that information in expanding (and deleting) and then recreating them to include them in the umbrella JAR.</li> 
      <li>If the developer changes any relevant JAR in the EAR (perhaps the app client JAR itself or perhaps one the client depends on) and then redeploys it, v2 creates a new umbrella JAR. Java Web Start launches download the entire JAR again. If the EAR contains large library JARs then the umbrella JAR will be large, even if the developer's change was to a small JAR.</li> 
      <li>If the EAR contains multiple app clients (probably rare but certainly supported) deployment cannot predict which one the user will launch - in fact that may change over different launches. So it cannot generate the umbrella in a way that supports the java launcher's fast splash screen support.</li> 
     </ul> <p>With deployment expanding and then recreating submodules to generate the umbrella EAR, with Java Web Start having to refresh the entire umbrella JAR after a change, and with the ACC re-expanding during each launch, there is a lot of wasted motion during both deployment and app client launch. In particular users have complained about launch delays when starting large app clients.</p> <h4><a name="Gfv3AppclientcontainerDesign-1.2.2Deploymentinv3"></a>1.2.2 Deployment in v3</h3> <p>EAR deployment retains the submodule JARs. </p> <p>Deployment does not generate an umbrella JAR that itself contains all the application JARs the app client requires. </p> <p>App client deployment generates, only if needed (see below), a small facade JAR for each app client. This app client facade refers to, rather than replaces, the developer's app client JAR. </p> <p><b>Implementation decision</b></p> <p>Downloading (both as part of deployment --retrieve and during get-client-stubs) will need to know the set of all JARs required by an app client. The Java Web Start support - perhaps in a server-side "app client container" (we'll need a different name desperately!) - will also need to know this in generating the JNLP and in responding to requests for JAR downloads. Probably best if deployment maintains an in-memory map of this information so get-client-stubs and Java Web Start support can use it without having to recompute it. The key to this map should probably be app-name/app-client-URI-with-EAR for clients in EARs and app-name for stand-alone app clients. </p> <p>EAR deployment creates a small app client group facade JAR for the EAR. The app client group facade does not <em>contain</em> the app client and library JARs as in v2 but rather <em>refers</em> to the app client JARs or their facades. This lets users continue to do what they have done in v2: specify a generated EAR-level JAR file in </p>
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">appclient -client</pre> 
       </div> 
      </div>
     </div> commands and use the -mainclass or -name appclient options to select from multiple app clients. <p></p> <p>To be consistent with v2, v3 will name the EAR facade $</p> 
     <div class="error">
      <span class="error">Unknown macro: {EAR-app-name}</span> 
     </div> <p>Client.jar. </p> <h4><a name="Gfv3AppclientcontainerDesign-1.2.3Downloadinv3"></a>1.2.3 Download in v3</h3> <p>During "deploy --retrieve" and "get-client-stubs" the server refers to the list of JARs which each app client uses and, as part of a single download operation, sends each JAR individually. The admin client already contains the logic to save each of these JARs in the correct place in the user-specified directory tree, mirroring the structure in the original EAR. This ensures that relative references in JARs' Class-Path settings to other JARs remain valid.</p> <p>Some terms:</p> 
     <ul> 
      <li><em>download directory</em> - the directory the user specifies in <em>deploy --retrieve downloadDir</em> or <em>get-client-stubs --appName myApp downloadDir</em></li> 
      <li><em>anchor directory</em> - a subdirectory within the download directory dedicated to a single application</li> 
     </ul> <p>GlassFish v2 users could download different generated JAR files into the same download directory. We needed to support the same behavior in v3, even though v3 downloads multiple JARs per application. So if the user deploys using</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">deploy --retrieve downloadDir myApp.ear</pre> 
       </div> 
      </div>
     </div> <p>he or she will see</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">downloadDir/
    myAppClient.jar
    myAppClient/
        ... various JARs ...</pre> 
       </div> 
      </div>
     </div> <p>More on this later.</p> <p>For Java Web Start the generated JNLP document for each app client lists each required JAR separately. Java Web Start can refresh, individually, only those JARs which are truly out-of-date. (This is an improvement over v2 in which any change, large or small, triggered the regeneration of the large, all-encompassing JAR file which Java Web Start would download again in its entirety.)</p> <p>By default, "deploy --retrieve" and "get-client-stubs" download all app clients in the specified app. We plan to add to the command syntax so users may (but are not required to) select a subset of all the clients in an app to download. This enhancement is not there yet.</p> <p><b>Note:</b> Users who want to copy downloaded clients need to copy the downloaded <em>directory subtree</em>, not just a single file as in v2. We have not published or documented the contents and layout of the download directory for v2, but certainly users can see what's there. We should encourage users to use the get-client-stubs command from each client that needs a particular client rather than doing file copies. At a minimum we should urge users to view the layout and contents of the download directory as opaque, owned by GlassFish, and subject to change. This is not an issue for Java Web Start launches because the download mechanism and storage are completely different.</p> <h4><a name="Gfv3AppclientcontainerDesign-1.2.4Launchinv3"></a>1.2.4 Launch in v3</h3> <p>The ACC does not expand any JARs. It constructs the runtime classpath for the client simply by referring to the downloaded client JAR. (see below - If deployment generated a facade app client JAR then the Class-Path in that JAR's manifest refers to all the relevant JARs.)</p> 
     <ul> 
      <li>Support for java command syntax on the appclient command</li> 
     </ul> <p>The appclient script now supports a blend of java command syntax with the v2 appclient syntax while remaining backward-compatible. The enhanced format is </p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">appclient [jvm-options] [acc-options] main-class-selector-expression [app arguments]</pre> 
       </div> 
      </div>
     </div> <p>where main-class-selector-expression is one of:</p> 
     <div class="table-wrap"> 
      <table class="confluenceTable">
       <tbody> 
        <tr> 
         <th class="confluenceTh">Expression</th> 
         <th class="confluenceTh">New in v3?</th> 
         <th class="confluenceTh">Notes</th> 
         <th class="confluenceTh">&nbsp;</th> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> -jar myClient.jar </td> 
         <td class="confluenceTd"> X </td> 
         <td class="confluenceTd"> JVM-style </td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> fully.qualified.class.name </td> 
         <td class="confluenceTd"> X </td> 
         <td class="confluenceTd"> JVM-style selection by class name </td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> -client myClient.jar </td> 
         <td class="confluenceTd">&nbsp;</td> 
         <td class="confluenceTd"> when used by itself (without -mainclass or -name) equivalent to -jar myClient.jar </td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> a class file </td> 
         <td class="confluenceTd">&nbsp;</td> 
         <td class="confluenceTd">&nbsp;</td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> -mainclass fully.qualified.class.name </td> 
         <td class="confluenceTd">&nbsp;</td> 
         <td class="confluenceTd"> without -client: equivalent to the JVM-style selection by class name with -client: selects from among several clients in the JAR </td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> -name (display name of app client) </td> 
         <td class="confluenceTd">&nbsp;</td> 
         <td class="confluenceTd"> selects from among several app clients deployed in the same EAR </td> 
         <td class="confluenceTd">&nbsp;</td> 
        </tr> 
       </tbody>
      </table> 
     </div> <p>In fact, to remain compatible with v2, the user can mix acc-options in among the app arguments although we should encourage users to follow the format above for clarity.</p> 
     <ul> 
      <li>Support for direct java command launches</li> 
     </ul> <p>Users can use</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">java -javaagent:${install-dir}/modules/gf-client.jar=mainclass=&lt;main class of client&gt; [rest of the java command]</pre> 
       </div> 
      </div>
     </div> <p>The -javaagent option gets the ACC JAR on the class path and its mainclass agent argument tells the ACC what the main class is. Unfortunately there is no supported or reliable way for a running Java program, even an agent, to find out what main class the java launcher chose to execute. The ACC needs to know that to do injection, so we need the user to tell the agent explicitly. I have filed an enhancement against Java for them to expose a way for a running program to find out which was the main class.</p> <h4><a name="Gfv3AppclientcontainerDesign-2.Serverside"></a>2. Server-side</h1> <h4><a name="Gfv3AppclientcontainerDesign-2.1GeneralApproach"></a>2.1 General Approach</h2> <p>Use an app client sniffer and deployer, just as with other module types. We do not need a server-side container initially but may use one to provide Java Web Start support. </p> <h4><a name="Gfv3AppclientcontainerDesign-2.2Sniffer"></a>2.2 Sniffer</h2> <p>Extends GenericSniffer. We have identified how GenericSniffer can be generalized to take on more of the likely common behavior, such as handling multiple stigmas. We can do this without breaking existing sniffers which extend it. We will not make these changes prior to M1.</p> 
     <ul> 
      <li>There are two stigmas (entries in an archive which unambiguously identify the module's type): META-INF/application-client.xml and META-INF/sun-application-client.xml. The AppClientSniffer.handles method returns true as soon as it detects either stigma.</li> 
      <li>Otherwise, the sniffer looks for the module's META-INF/MANIFEST.MF. If the manifest exists and specifies Main-Class then return true.</li> 
      <li>Return false.</li> 
     </ul> <h4><a name="Gfv3AppclientcontainerDesign-2.3Deployer"></a>2.3 Deployer</h2> <p>The app client deployer has these main jobs:</p> 
     <ol> 
      <li>Keep track of the JARs that should be downloaded for each app client and for each EAR containing app clients.</li> 
      <li><del>If necessary, c</del> Create a small facade app client JAR to front-end the developer's app client JAR.</li> 
     </ol> <p>The EAR deployer has an added job:</p> 
     <ol> 
      <li>If the EAR contains at least one app client, create a small facade for the EAR.</li> 
     </ol> <h4><a name="Gfv3AppclientcontainerDesign-2.3.1TrackingrequiredJARs"></a>2.3.1 Tracking required JARs</h3> <p>If this is a stand-alone app client deployment, the only required JAR is the app client JAR itself. </p> <p>If this is an app client nested inside an EAR, the app client deployer starts with the Class-Path entry in the app client JAR and all JARs in the EAR's library directory (if any). With this list of JARs as a starting point the deployer builds the transitive closure of the required JARs (by checking each JAR's Class-Path entry and adding any as-yet-unseen JARs to the overall list to process). All these JARs will be within the directory the EAR deployer created when it expanded the EAR and the app client deployer records the URIs to each of these JARs <b>relative to the location of the app client JAR in that expanded directory</b>. </p> <p>The app client deployer stores the result in an in-memory map. (The key is &lt;application-name&gt;/&lt;app-client-URI-within-the-EAR&gt; for nested app clients and &lt;application-name&gt; for stand-alone app clients. There is currently no unique identification of app clients within an EAR using a name; the URI path to the app client JAR within the EAR is unique so we use that).</p> <p>The deployer.clean method should invoke super.clean() and then remove that app client's entries from the map.</p> <p>For the EAR case with multiple app clients to be downloaded, each individual app client deployer can use outboundPayload.attachFile to arrange for that file's download. The EAR deployer can also use outboundPayload.attachFile to arrange for the EAR facade to be downloaded. The order of calls to attachFile is not important. This is all conditional on whether the deployment request specifies --retrieve.</p> <h4><a name="Gfv3AppclientcontainerDesign-2.3.2CreatingafacadeappclientJAR"></a>2.3.2 Creating a facade app client JAR</h3> <p>We will always create a facade app client JAR. This will allow the user to launch a deployed app client JAR using a simple java command because we will specify a main class in the facade that prepares the ACC and then launches the developer's original main class.</p> <p>The spec obligates us to make all EAR library JARs available to nested app clients at runtime. If the transitive closure starting from the app client JAR's Class-Path does not include all the EAR's library JARs then deployment will make sure they appear in the manifest Class-Path for the client facade. </p> <p>Creating the client facade:</p> 
     <ul> 
      <li>Derive the name of the facade (developer's-app-client-jar-name)Client.jar</li> 
      <li>Create a new facade app client JAR using this name within the generated directory for the app: 
       <ul> 
        <li>Same relative URI location as the developer's app client JAR</li> 
        <li>Manifest 
         <ul> 
          <li>Class-Path: (developer's client JAR) (all entries from the Class-Path of the original app client JAR) (library JARs in the EAR)</li> 
          <li>Main-Class: org.glassfish.appclient.client.AppClientFacade</li> 
          <li>GlassFish-AppClient-Main-Class: (original Main-Class from the developer's app client JAR)</li> 
          <li>GlassFish-AppClient: (unique name generated for the original app client JAR)</li> 
          <li>SplashScreen-Image: copied from original</li> 
         </ul> </li> 
        <li>Copy the splash screen image JarEntry from the original app client JAR and create a new JarEntry for it in the facade JAR</li> 
        <li>Store a copy of the GlassFish-provided AppClientFacade.class as a new JarEntry in the facade JAR (same name and contents). (This class is in the appclient/client/gf-acc-module module which is accessible to the server.)</li> 
       </ul> </li> 
     </ul> <p>See notes in the v3 download section.</p> <h4><a name="Gfv3AppclientcontainerDesign-2.3.3Creatingan%22appclientgroup%22facadeJARfile%28afacadeattheEARlevel%29"></a>2.3.3 Creating an "app client group" facade JAR file (a facade at the EAR level)</h3> <p>Why would we do this? Because in v2 users can launch app clients using </p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">appclient -client umbrella.jar -mainclass "main-class ...</pre> 
       </div> 
      </div>
     </div> <p>or </p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">appclient -client umbrella.jar -name "client-name" ...</pre> 
       </div> 
      </div>
     </div> <p>to select which of several clients from the EAR to start. To support this technique in v3 we will need to create a facade at the EAR level. </p> <p>The EAR deployer will generate the app client group facade if the EAR contains at least one app client:</p> 
     <ul> 
      <li>Manifest 
       <ul> 
        <li>Main-Class: org.glassfish.appclient.client.AppClientGroupFacade</li> 
        <li>(no "Class-Path:" entry)</li> 
        <li>GlassFish-AppClient-Group: (the URIs relative to the top of the EAR for each facade app client JAR)</li> 
        <li>(no SplashScreen-Image entry)</li> 
       </ul> </li> 
      <li>(no splash screen image JarEntry)</li> 
      <li>A copy of AppClientGroupFacade.class</li> 
     </ul> <p>By building the app client group facade this way we let users launch it using either the appclient script as in v2 or a direct java command. Either way the behavior is the same as in v2.</p> <p>In the future if the EAR contains only one app client we might consider copying the splash screen image and the corresponding manifest entry into the EAR facade. No urgency to this, though.</p> <p><b>Note:</b></p> <p>In the EAR case, the deployer generates each app client facade JAR in the same position relative to the top of the EAR that the developer's original app client JAR occupies. That is, after the files are downloaded to the client, the facade app client JAR and the the original one will be in the same directory. This means that in the facade's manifest, the two references to the original - the first part of the generated Class-Path and the GlassFish-AppClient - should be just the name and file type of the original; no relative path information should be there even if the original JAR was in a subdirectory of the EAR. </p> <p>Further, for app clients nested inside an EAR, the Class-Path for the app client facade JAR must refer to library JARs <em>relative to where the client is within the EAR</em>. Basically, this means that for every "/" in the relative URI for the app client JAR within the EAR, each Class-Path entry for a library JAR needs to have an additional "../" prefix in its URI. See the example below.</p> <p>Note that the app client group facade will reside at the top of the download directory for the app, so its references to the generated app client-level facade JARs will add a prefix to the URIs for the original app client JARs within the EAR, the prefix pointing to the app's download directory. That is, given an original EAR myApp.ear that looks like this</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">foo/
   myClient.jar

   bar/
      otherClient.jar
lib/
   math.jar</pre> 
       </div> 
      </div>
     </div> <p>the deployer should generate the files so that the download directory and the manifests look like this:</p> 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">downloadDir/
   myAppClient.jar (app client group facade - naming follows the convention from v2 but content is different)
   myAppClient/ (new in v3 - collects everything for the myApp download except the app client group facade
      foo/
         myClient.jar (original developer's app client JAR)
         myClientClient.jar (app client facade)

         bar/
            otherClient.jar (original developer's app client JAR)
            otherClientClient.jar (app client facade)

      lib/
         math.jar (unchanged by deployer)</pre> 
       </div> 
      </div>
     </div> <p>Manifests:</p> 
     <div class="table-wrap"> 
      <table class="confluenceTable">
       <tbody> 
        <tr> 
         <th class="confluenceTh">Generated facade</th> 
         <th class="confluenceTh">Partial Manifest</th> 
         <th class="confluenceTh">&nbsp;</th> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> myAppClient.jar </td> 
         <td class="confluenceTd">~UWC_TOKEN_START~1278095716120~UWC_TOKEN_END| </td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> foo/myClientClient.jar </td> 
         <td class="confluenceTd">~UWC_TOKEN_START~1278095716121~UWC_TOKEN_END| </td> 
        </tr> 
        <tr> 
         <td class="confluenceTd"> foo/bar/otherClientClient.jar </td> 
         <td class="confluenceTd">~UWC_TOKEN_START~1278095716122~UWC_TOKEN_END| </td> 
        </tr> 
       </tbody>
      </table> 
     </div> <p>Note that for a stand-alone app client also the Class-Path and GlassFish-AppClient manifest entries will refer to the original JAR only by name and type (no path). So the logic which generates the app client facade works the same in both cases.</p> <h4><a name="Gfv3AppclientcontainerDesign-2.4deployandredeploycommands"></a>2.4 deploy and redeploy commands</h2> <p>When the user specifies --retrieve, the deploy and redeploy commands send the required files back to the client in the response payload. </p> 
     <ul> 
      <li>If an EAR was deployed, the app client group facade and the transitive closure of all JARs referenced from any app client.</li> 
      <li>For each app client: 
       <ul> 
        <li>The app client facade (with name xxxClient.jar).</li> 
        <li>The original app client JAR xxx.jar.</li> 
       </ul> </li> 
     </ul> <p>This approach allows us to leave the developer's original app client JAR completely alone - not even copying it - while giving. </p> <h4><a name="Gfv3AppclientcontainerDesign-2.4.1DownloadingasubsetofappclientsduringEARdeployment"></a>2.4.1 Downloading a subset of app clients during EAR deployment</h3> <p>(post M1 at least)<br> We might expand the </p>
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">--retrieve local-dir-name</pre> 
       </div> 
      </div>
     </div> option to, for example, 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">--retrieve:client-URIs local-dir-name</pre> 
       </div> 
      </div>
     </div> where the client-URIs expression could be a comma-separated list of URIs to the clients of interest, perhaps excluding the trailing .jar file type. We could support wildcarding. <p></p> <p>The added syntax would be valid only during an EAR deployment – stand-alone app clients contain only one client. The download would include the set union of the JARs required by each individual selected client. </p> <p>In reality this syntax is rather ugly and not intuitive. We could surely find a better solution but providing this enhancement is a low priority.</p> <h4><a name="Gfv3AppclientcontainerDesign-2.5getclientstubscommand"></a>2.5 get-client-stubs command</h2> <p>If the user identifies a stand-alone app client then GlassFish downloads the JARs required by that app client as recorded in the in-memory data structure.</p> <p>If the user identifies an EAR and nothing else, GlassFish downloads all JARs needed by all app clients. </p> <p>Post-M1 we'll propose syntax changes to get-client-stubs so users can select a subset of the clients in an EAR. Might be so simple as the </p>
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">--appName</pre> 
       </div> 
      </div>
     </div> option would accept 
     <div class="code panel" style="border-width: 1px;">
      <div class="codeContent panelContent"> 
       <div id="root"> 
        <pre class="theme: Confluence; brush: java; gutter: false">appName/clientName</pre> 
       </div> 
      </div>
     </div> for example.<p></p> <h4><a name="Gfv3AppclientcontainerDesign-2.6JavaWebStartsupport"></a>2.6 Java Web Start support</h2> <h4><a name="Gfv3AppclientcontainerDesign-3.Clientside"></a>3. Client-side</h1> <h4><a name="Gfv3AppclientcontainerDesign-3.1AppClientContainer"></a>3.1 App Client Container</h2> <h4><a name="Gfv3AppclientcontainerDesign-3.2JavaWebStart"></a>3.2 Java Web Start</h2> 
     <hr> </td> 
   </tr> 
  </tbody>
 </table>    
</body></div>
        <br/>

        <!-- footer================================================== -->
        <footer class="well">
            <div class="container">

                <div class="row-fluid" id="bottom-info">
                    <!--div class="span6 pagination-centered" id="social"-->
                    <div class="span4" id="social">			
                        <a href="http://blogs.oracle.com/theaquarium/"><img src="../images/icons/TheAquarium.png"></a>
                        <a href="https://twitter.com/glassfish"><img src="../images/icons/twitter.png"></a>
                        <a href="https://plus.google.com/communities/106098646151660933759"><img src="../images/icons/google.png"></a>
                        <a href="http://www.linkedin.com/groups/GlassFish-Users-106819/about"><img src="../images/icons/linkedin.png"></a>
                        <a href="http://www.youtube.com/user/GlassFishVideos"><img src="../images/icons/youtube.png"></a>
                        <a href="https://www.facebook.com/GlassFish"><img src="../images/icons/facebook.png"></a>
                    </div>

                    <div class="span8" id="copyright">Page last changed on Jul 02, 2010 by 
<font color="#0050B2">am74686</font>. Exported from wikis.oracle.com on May 27, 2015 20:44.<br/>
                        Copyright &copy; 2005-2015 Oracle Corporation and/or its affiliates.</div>
                </div>
            </div>
        </footer>

        <!-- ================================================== -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/bootstrap-tab.js"></script>
	<script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<!--  Begin SiteCatalyst code  -->
  	<!--  End SiteCatalyst code  -->
    </body>
</html>